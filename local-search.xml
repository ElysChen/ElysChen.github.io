<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法分析</title>
    <link href="/2024/10/31/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <url>/2024/10/31/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="amortized-analysis均摊分析"><font color=orange>Amortized Analysis（均摊分析）</font></h1><p>均摊分析的目的是得到一系列操作的时间复杂度的更为准确的上界。我们在考量一系列操作的时候，经常会首先得到其中开支最大的操作或某操作在特定情况下有最大开支，并用它直接乘以操作数来得到一系列操作的时间复杂度的一个上界。然而，使用这个上界来评估这一系列操作的时间复杂度往往过分夸大了真实的开支，所以需要对于开支最大的操作何时会出现，何时会造成较大开销要有一个更为细致的考量，这成为<strong>均摊分析</strong>。</p><h2 id="定义"><font color=brown>定义</font></h2><p>若对任意<span class="math inline">\(k\in\mathbb{N}^+\)</span>，从可执行的操作集合中取出的<span class="math inline">\(k\)</span>个任意的操作的时间开销之和<span class="math inline">\(\leq \sum\limits_{i=1}^{k}\hat{c}(n_i)\)</span>，这里<span class="math inline">\(n_i\)</span>指的是在执行选定的操作序列中第<span class="math inline">\(i\)</span>个操作时数据结构的规模。</p><h1 id="一些数学手段"><font color=orange>一些数学手段</font></h1><h2 id="stirlings-approximation"><font color=brown>Stirling's approximation</font></h2><p><span class="math display">\[\lim\limits_{n\rightarrow + \infty}\frac{n!}{\sqrt{2\pi n}(\frac{n}{e})^n}=1\]</span> 斯特令近似常用于在<span class="math inline">\(n\)</span>很大时估计<span class="math inline">\(n!\)</span>，是一个很紧的近似。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构与算法分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>learning0</title>
    <link href="/2024/10/25/learning0/"/>
    <url>/2024/10/25/learning0/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="呀嘞呀嘞，密码不对还想硬闯吗？真是拦不住的大小姐~" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b26b8ca45bce8fb4538ae60638c9a00eaf28d6addb1c85eb1b01a443aba0563c">500036ade4324703080d4b46a2870e61a73fe1d88dbe1acf67cdab44fedecaeda749628525812a8caaa5c3db112688a5787ddd6bf3f73fc3e8887a4dc806690d41be719710700607ac7e0704c8bc9467f02d9e82988e10e3b4fedb2cc31c5ec6b31403cbf83678d7ed5766d5ec3d9a0c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">呀嘞呀嘞，要输入密码的哦</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>摸鱼</category>
      
      <category>learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS</title>
    <link href="/2024/10/23/ICS/"/>
    <url>/2024/10/23/ICS/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-程序的转换及机器级表示"><font color=orange>第三章 程序的转换及机器级表示</font></h1><h2 id="总述"><font color=brown>总述</font></h2><ul><li>计算机指令分为微指令、机器指令和伪（宏）指令，微指令属于硬件范畴；伪指令是若干机器指令组成的序列，属于软件范畴；机器指令介于二者之间。机器指令的汇编语言表示形式为<strong>汇编指令</strong>。机器指令与汇编指令一一对应，<strong>都与具体机器结构有关</strong>，都属于<strong>机器级指令</strong>。<br /></li><li>书中主要阐释C语言和IA-32机器级指令的对应关系，使用寄存器传送语言(RTL)，符号约定如下。</li></ul><h2 id="符号约定"><font color=brown>符号约定</font></h2><h3 id="寄存器语言"><font color=brown>寄存器语言</font></h3><ul><li><strong>R[r]</strong> 表示寄存器r的内容，<strong>M[addr]</strong> 表示存储单元addr的内容，寄存器r采用不带%的形式表示；<br /></li><li><strong>M[PC]</strong> 表示PC所指存储单元的内容，<strong>M[R[r]]</strong> 表示寄存器r的内容所指的存储单元的内容；<br /></li><li>传送方向以<span class="math inline">\(\leftarrow\)</span>表示，传送源在右，传送目的在左；</li><li>书中寄存器名称书写约定：寄存器的名称若出现在单独一行的汇编指令或寄存器传送语言中则用小写，若出现在正文段落或其他部分则大写；<br /></li><li>书中汇编指令及其名称书写约定：具体一条汇编指令或其名称用小写，泛指一类指令的指令名称时用大写。</li></ul><h3 id="汇编格式"><font color=brown>汇编格式</font></h3><p>采用<strong>AT&amp;T</strong> 汇编格式，格式要求如下： <img src="https://www.helloimg.com/i/2024/10/23/6718e823c2ef2.png" alt="AT&amp;T格式" /></p><h2 id="section"><font color=brown></font></h2><h1 id="x86-64内联汇编"><font color=orange>x86-64内联汇编</font></h1><h2 id="字长的历史"><font color=brown>字长的历史</font></h2><ul><li>字长：CPU中处理的自然单元，是指针的大小，可以直接进行整数/位运算。<br /></li><li>8位机（最早期）</li><li>16位机（8086/8088）：地址线是20bit的，4位段寄存器，16位PC，在确定了段为<span class="math inline">\(2^4\)</span>个段中的某一个后，再用PC指示行数。<br /></li><li>32位机（Intel x86）</li><li>64位机（x86-64;AARch64;RV64;...）</li></ul>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序与搜索算法</title>
    <link href="/2024/10/19/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <url>/2024/10/19/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法">排序算法</h1><h2 id="heapsort">HeapSort</h2><p>用Binary Max-heap来实现排序，首先很容易想到的就是首先从原数组生成一个二叉最大堆，然后调用<span class="math inline">\((n-1)\)</span>次HeapExtractMax()。当然，为了减少空间开支，每次取出的当前最大元素可以放到后面。伪代码如下：<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">HeapSort(data[<span class="hljs-number">1</span>…n]):<br>    heap = BuildMaxHeap(data[<span class="hljs-number">1</span>…n])<br>    <span class="hljs-keyword">for</span> i=n down to <span class="hljs-number">2</span><br>        cur_max = heap.HeapExtractMax()<br>        data[i] = cur_max<br></code></pre></td></tr></table></figure></p><p>对于循环中调用HeapExtractMax()，时间复杂度为<span class="math inline">\(\sum\limits_{i=2}^{n}O(lgi)=O(lg(n!))=O(nlgn)\)</span>.对于前面根据数组建立二叉最大堆，如果使用<span class="math inline">\(n\)</span>次HeapInsert()，我们将再次花费<span class="math inline">\(O(nlgn)\)</span>.<br /><font color=#F08080 size=4 face="黑体">然而，我们有更好的建立二叉最大堆的手段.</font>考虑分治算法，我们将原数组看为一个二叉堆，只是这个二叉堆需要恢复最大堆的性质，那么最底一层的视为单节点的二叉最大堆，此后将索引移至上一层的最右侧节点，对它及它的两个子节点使用MaxHeapify()函数（见同目录下“常用数据结构”一文）维护二叉最大堆的性质，以此类推。故BuildMaxHeap()的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">BuildMaxHeap(data[<span class="hljs-number">1</span>…n]):<br>    heap_size = n<br>    <span class="hljs-keyword">for</span> i=Floor(n/<span class="hljs-number">2</span>) down to <span class="hljs-number">1</span><br>        MaxHeapify(i)<br></code></pre></td></tr></table></figure><p>考虑到高度为<span class="math inline">\(h\)</span>的节点应不超过<span class="math inline">\(\lceil \frac{n}{2^{h+1}}\rceil\)</span>个，每个高度为<span class="math inline">\(h\)</span>的节点使用MaxHeapify()的时间复杂度均为<span class="math inline">\(O(h)\)</span>，因而BuildMaxHeap的时间复杂度为<span class="math inline">\(\sum\limits_{h=0}^{\lfloor lgn\rfloor}(\lceil \frac{n}{2^{h+1}}\rceil O(h))=O(n)\)</span>.</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构与算法分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遗传算法与模拟退火算法</title>
    <link href="/2024/10/19/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E4%B8%8E%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/"/>
    <url>/2024/10/19/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E4%B8%8E%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数模算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用数据结构</title>
    <link href="/2024/10/19/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/10/19/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="抽象数据结构"><font color=orange>抽象数据结构</font></h1><p>抽象数据结构用以规定一类数据结构一定能执行的操作有哪些，但并不规定其具体实现。</p><h2 id="queue"><font color=brown>Queue</font></h2><h3 id="概述">概述</h3><p>队列都支持两个操作：</p><ul><li>Add(x):将元素x加入到队列中<br /></li><li>Remove():将顺序中下一个元素y从队列中移除，并返回y。（所谓的顺序和具体实现有关，如FIFO，LIFO）</li></ul><h3 id="fifo-queue">FIFO Queue</h3><p>支持操作如下：</p><ul><li>Add(x) or Enqueue(x): add x to the end of the queue.<br /></li><li>Remove() or Dequeue(): remove the first item from the queue.</li></ul><h3 id="lifo-queuestack">LIFO Queue(Stack)</h3><p>支持操作如下：</p><ul><li>Add(x) or Push(x): add x to the top of the stack.</li><li>Remove() or Pop(): remove the item at the top of the stack.</li></ul><h2 id="set"><font color=brown>Set</font></h2><h3 id="概述-1">概述</h3><ul><li>一组元素，每个元素都拥有一个key值和一个存放数据的空间用以存放相关的属性。</li><li>通常key值是互不相同的。</li><li>特别地，对于OSet(Ordered set)，其中元素按照key值大小可以找到前驱和后继。</li></ul><h3 id="支持的操作">支持的操作</h3><p>对于一般的Set而言,需要能够支持以下操作：</p><ul><li>Search(S,k): Find an element in S with key value k.<br /></li><li>Insert(S,x): Add x to S. (What if element with same key exists?-&gt;自己做相应处理，比如说可以用一个链表来存放key相同但数据不同的输入。)<br /></li><li>Remove(S,x): Remove element x from S, assuming x is in S.<br /></li><li>Remove(S,k): Remove element with key value k from S.</li></ul><p><br></p><p>特别地，对于OSet而言，在 <strong>支持上述操作的基础上</strong> 还应支持下述操作：</p><ul><li>Min(S) and Max(S): Find minimum/maximum element in S.<br /></li><li>Successor(S,x) or Successor(S,k): Find smallest element in S that is larger than x.key (or key k).<br /></li><li>Predecessor(S,x) or Predecessor(S,k): Find largest element in S that is smaller than x.key (or key k).</li></ul><h1 id="heap堆"><font color=orange>Heap(堆)</font></h1><p>堆是用来存放优先队列的数据结构。二叉堆是完全二叉树中的一种，指除去叶节点所在层外各层均填满，且叶节点所在层的节点都尽可能挂靠在左侧父节点上。</p><ul><li>Max-heap(最大堆/大顶堆):除根节点外，各节点的值均小于其父节点的值。<br /></li><li>Min-heap(最小堆/小顶堆):除根节点外，各节点的值均大于其父节点的值。</li></ul><p>常使用数组来存放二叉堆，记节点<span class="math inline">\(u\)</span>的索引为<span class="math inline">\(index_u\)</span>，则其父节点（若有）索引为<span class="math inline">\(\lfloor index_u/2\rfloor\)</span>，其左子节点（若有）索引为<span class="math inline">\(2index_u\)</span>，右子节点（若有）索引为<span class="math inline">\(2index_u+1\)</span>.<br />如此，通过一个节点去找到其父节点和子节点只需<span class="math inline">\(O(1)\)</span>的时间.</p><h2 id="binary-max-heap二叉大顶堆二叉最大堆"><font color=orange>Binary Max-heap（二叉大顶堆/二叉最大堆）</font></h2><h3 id="支持的操作-1"><font color=brown>支持的操作</font></h3><ul><li>HeapInsert : 向Max-heap中插入一个元素；<br /></li><li>HeapGetMax : 从Max-heap中得到值最大的元素（注意并不将该元素从堆中取出！）；<br /></li><li>HeapExtractMax : 从Max-heap中得到并移除值最大的元素。</li></ul><h3 id="支持操作的实现"><font color=brown>支持操作的实现</font></h3><h4 id="o-heapinsert"><span class="math inline">\(1^o\)</span> HeapInsert</h4><p><font color=#B0C4DE size=4 face="黑体">概述</font> 实现插入的同时要维护最大堆的性质。欲插入新元素，可将新元素接到数组的尾部，在图形上相当于将新元素挂靠在首个子节点个数小于2的节点下。此后一直比较新元素的值和其父节点的值，若新元素的值更大，则交换两节点；否则，算法终止。若无父节点，即新元素已成为新的根节点，算法亦终止。<br /><font color=#B0C4DE size=4 face="黑体">正确性</font> 若发生交换，则原父节点的值必定小于插入元素的值，，进而插入元素的值大于原父节点的左子节点以及以左子节点为祖先的所有节点的值；而原父节点又必然大于以插入元素所在节点为祖先节点的所有子节点的值，故以交换之后插入元素所在节点为祖先节点的所有子节点构成的树必然保持了原性质，而除去这些节点以外的原来所有节点所构成的树没有和插入元素前无变化，故也最大堆性质不变。唯一会破坏性质的地方就是在插入元素现在所在节点及其父节点之间，即两颗子树连接的地方。由归纳法，可推出算法正确性。<br /><font color=#B0C4DE size=4 face="黑体">伪代码</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">HeapInsert(x):<br>    heap_size++<br>    data[heap_size] = x<br>    idx = heap_size<br>    <span class="hljs-keyword">while</span> (idx&gt;<span class="hljs-number">1</span> and data[Floor(idx/<span class="hljs-number">2</span>)]&lt;data[idx])<br>    Swap(data[Floor(idx/<span class="hljs-number">2</span>)], data[idx])<br>    idx = Floor(idx/<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><font color=#B0C4DE size=4 face="黑体">时间复杂度</font> 显然循环数最大为树高，而树高为<span class="math inline">\(O(\lceil lg(n+1)\rceil-1)=O(lgn)\)</span></p><h4 id="o-heapgetmax"><span class="math inline">\(2^o\)</span> HeapGetMax</h4><p>直接将索引为1的元素的值赋予一个新变量即可。时间为<span class="math inline">\(O(1)\)</span>。</p><h4 id="o-heapextractmax"><span class="math inline">\(3^o\)</span> HeapExtractMax</h4><p><font color=#B0C4DE size=4 face="黑体">概述</font> 将根节点移除，将数组中索引最大的元素（记为元素<span class="math inline">\(u\)</span>）填入根节点位置，随后逐层比较<span class="math inline">\(u\)</span>和其所在位置的两个子节点的大小关系，若<span class="math inline">\(u\)</span>比较大的子节点的值小，则交换二者。否则，算法停止。<br /><font color=#B0C4DE size=4 face="黑体">正确性</font> 使用归纳法。对于树高为1（<font color=#F08080 size=4 face="黑体">为了行文方便，这里树高指的是根节点的高度+1，因而只有一个节点的树的树高为1，而该节点的高度为0.</font>）的树，即只有一个节点，则显然算法正确；假定对于高度为<span class="math inline">\(k\)</span>的树该算法正确，则对于高度为<span class="math inline">\(k+1\)</span>的树，若索引最大的节点<span class="math inline">\(u\)</span>的值大于深度为1的两个子节点中值较大的，则由于以两子节点为根节点的子树内部没有发生变化，故新树整体仍然维持了最大堆性质；若不然，则<span class="math inline">\(u\)</span>与值较大的子节点交换，值较大的子节点大于另一子节点，而以另一子节点为根节点的子树内部未发生变化，故最大堆性质保留；而<span class="math inline">\(u\)</span>在交换后，成为了一个高度不大于<span class="math inline">\(k\)</span>的树的根节点，而以其两个子节点为根节点的子树内部均未发生变化，由归纳假设知<span class="math inline">\(u\)</span>最后会排到合适的位置。综上，算法正确。<br /><font color=#B0C4DE size=4 face="黑体">伪代码</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C">HeapExtractMax():<br>    max_item = data[<span class="hljs-number">1</span>]<br>    data[<span class="hljs-number">1</span>] = data[heap_size--]<br>    MaxHeapify(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> max_item<br><br>MaxHeapify(idx):<br>    idx_l = <span class="hljs-number">2</span>*i, idx_r = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span><br>    idx_max = (idx_l&lt;=heap_size &amp;&amp; data[idx_l]&gt;data[idx])?idx_l:idx<br>    idx_max = (idx_r&lt;=heap_size &amp;&amp; data[idx_r]&gt;data[idx_max])?idx_r:idx_max<br>    <span class="hljs-keyword">if</span> (idx_max != idx)<br>        Swap(data[idx_max], data[idx])<br>        MaxHeapify(idx_max)<br><br></code></pre></td></tr></table></figure><p><font color=#B0C4DE size=4 face="黑体">时间复杂度</font> 显然递归调用数最大为树高，故时间复杂度亦为<span class="math inline">\(O(lgn)\)</span>.</p><h2 id="priority-queue优先队列"><font color=orange>Priority Queue（优先队列）</font></h2><h3 id="支持的操作-2"><font color=brown>支持的操作</font></h3><ul><li>Add(item) : HeapInsert(item)<br /></li><li>Remove() : HeapExtractMax()<br /></li><li>GetMax() : HeapGetMax()<br /></li><li>UpdatePriority(item,val)</li></ul><h3 id="支持操作的实现-1"><font color=brown>支持操作的实现</font></h3><h4 id="oadditem"><span class="math inline">\(1^o\)</span>Add(item)</h4><p>使用HeapInsert(item)即可，时间复杂度即为HeapInsert(item)的时间复杂度，为<span class="math inline">\(O(lgn)\)</span>.</p><h4 id="oremove"><span class="math inline">\(2^o\)</span>Remove</h4><p>使用HeapExtract()即可，时间复杂度与之相同，为<span class="math inline">\(O(lgn)\)</span>.</p><h4 id="ogetmax"><span class="math inline">\(3^o\)</span>GetMax</h4><h4 id="oupdatepriorityitemval"><span class="math inline">\(4^o\)</span>UpdatePriority(item,val)</h4><h2 id="heapsort"><font color=orange>HeapSort</font></h2><p>请见同目录下“排序与搜索算法”一文。</p><h1 id="searching-tree"><font color=orange>Searching Tree</font></h1><h1 id="hashing哈希表"><font color=orange>Hashing（哈希表）</font></h1><h2 id="概述-2"><font color=brown>概述</font></h2><p>目前，对于OSet类型的数据结构的各种具体实现，我们有下表：<br /><img src="https://www.helloimg.com/i/2024/10/25/671b9b109403a.png" alt="除哈希表外四类OSet具体实现" /><br />当我们仅关注Insert,Remove和Search操作时，我们希望能有更好的具体实现。哈希表应运而生。<br />记所有key值来自一个很大的集合 <span class="math inline">\(U\)</span>,分配给哈希表的bucket为从0号到<span class="math inline">\(m-1\)</span>号共<span class="math inline">\(m\)</span>个，将key值映射为0到<span class="math inline">\(m-1\)</span>的整数的函数为哈希函数<span class="math inline">\(h(k)\)</span>。要存储的元素共<span class="math inline">\(n\)</span>个。<br />定义负载因子(load factor)<span class="math inline">\(\alpha=\frac{n}{m}\)</span>.构建出的哈希表通常记为<span class="math inline">\(T\)</span>.</p><h2 id="chaining-hash链地址法"><font color=orange>Chaining Hash（链地址法）</font></h2><p>一般而言，会有<span class="math inline">\(m&lt;&lt;|U|\)</span>。因而，必然会有碰撞(collision)的发生，即<span class="math inline">\(\exists k_1,k_2~s.t.~h(k_1)= ~h(k_2)~when~k_1\neq k_2\)</span>。为应对碰撞，0号到<span class="math inline">\(m-1\)</span>号bucket都存放一个指针，指向<span class="math inline">\(h(k)=index(index\in \{0,1,...,m-1\})\)</span>的首个元素，首个元素再指向被哈希函数同等映射到此处的元素，如下图：<br /><img src="https://www.helloimg.com/i/2024/10/25/671ba094ee8cc.png" /></p><h3 id="支持操作的实现-2"><font color=brown>支持操作的实现</font></h3><h4 id="oinsertx"><span class="math inline">\(1^o\)</span>Insert(x)</h4><p>计算h(x.key)，找到对应bucket的指针，从头插入x，时间复杂度显然为O(1)。</p><h4 id="oremovex"><span class="math inline">\(2^o\)</span>Remove(x)</h4><p><font color=#F08080 size=4 face="黑体">注意Remove(x)和Insert(x)里面x都是一个指向某节点的指针！</font><br />如果使用双向链表，显然O(1)内就可以实现删除。</p><h4 id="osearchk"><span class="math inline">\(3^o\)</span>Search(k)</h4><p>先计算<span class="math inline">\(h(k)\)</span>，再到对应的bucket里面去找键值为key的元素，时间复杂度就和对应bucket的链表长度有关系了。最坏情况可以到<span class="math inline">\(\Theta(n)\)</span>。我们有以下考量：</p><h5 id="isimple-uniform-hashing-assumption">i&gt;Simple Uniform Hashing Assumption</h5><p>假设有二：1.每个键值key被等可能地映射到每个bucket；2.键值的映射相互独立。<br /><br> 此时，负载因子<span class="math inline">\(\alpha\)</span>即为每个bucket中key值数量的均值。当哈希表中不存在<span class="math inline">\(k\)</span>时，所需的平均时间复杂度即为<span class="math inline">\(O(1+\alpha)\)</span>，前面的&quot;1&quot;源于计算<span class="math inline">\(h(k)\)</span>的用时。<br />当哈希表中存在<span class="math inline">\(k\)</span>时，计算如下：<br /><img src="https://www.helloimg.com/i/2024/10/26/671c657ade4e5.png" /><br />这里<span class="math inline">\(C_i\)</span>是找到第<span class="math inline">\(i\)</span>个插入的节点<span class="math inline">\(x\)</span>的花销，由于可以认为<span class="math inline">\(k\)</span>和相应的节点是一一对应的，所以其实也就是在寻找键值为<span class="math inline">\(k\)</span>的节点。<span class="math inline">\(X_{ij}\)</span>用以标识<span class="math inline">\(x_i\)</span>和<span class="math inline">\(x_j\)</span>的key在被哈希函数映射后是否相等。若相等则为1，不相等则为0，这里其实是用来计算<span class="math inline">\(k\)</span>所在的bucket的链表长度的。为什么第一行里面是<span class="math inline">\(\mathbf{E}[1+\sum\limits_{j=i+1}^nX_{ij}]\)</span>呢？感觉上是因为<span class="math inline">\(X_{ij}=X_{ji}\)</span>，这样相当于算了一半，在渐近意义上没有变化。而对于<span class="math inline">\(\mathbf{E}[X_{ij}]\)</span>来说，给定一个<span class="math inline">\(x_i\)</span>，<span class="math inline">\(x_j\)</span>的<span class="math inline">\(key\)</span>值与之相等的概率当然就是<span class="math inline">\(\frac{1}{m}\)</span>了（两条假设联合保证）。<br />进一步地，有以下不要求证明的结论：<br /><img src="https://www.helloimg.com/i/2024/10/26/671c67d6ce290.png" /></p><h5 id="iiuniversal-hashing">ii&gt;Universal Hashing</h5><p>每次构建时哈希表时，从哈希函数族中随机挑选出一个哈希函数<span class="math inline">\(h(key)\)</span>，对于这个哈希表而言，其采用的哈希函数固定为<span class="math inline">\(h(key)\)</span>。对哈希函数族有以下要求：<br /><img src="https://www.helloimg.com/i/2024/10/26/671c6a0ba6b0f.png" /><br />这就限制了哈希函数族中的每个哈希函数都不能太容易产生碰撞。由于对任意<span class="math inline">\(x\neq y\)</span>，任取一个哈希函数，该哈希函数使得<span class="math inline">\(h(x)=h(y)\)</span>的概率小于等于<span class="math inline">\(\frac{1}{m}\)</span>,那么对于这组<span class="math inline">\(x,y\)</span>，在哈希函数族中使得<span class="math inline">\(h(x)=h(y)\)</span>的函数个数当然就不多于<span class="math inline">\(\frac{|H|}{m}\)</span>了。<br />计算Search(k)的开销可以做以下讨论：<br /><img src="https://www.helloimg.com/i/2024/10/26/671c6d8a0dced.png" /><br />当<span class="math inline">\(k\)</span>不在哈希表<span class="math inline">\(T\)</span>中时，这<span class="math inline">\(n\)</span>个已插入的元素，每个元素经哈希函数映射后的值和<span class="math inline">\(h(k)\)</span>相等的概率均不大于<span class="math inline">\(\frac{1}{m}\)</span>，因而索引为<span class="math inline">\(h(k)\)</span>的bucket的长度期望不大于<span class="math inline">\(\frac{n}{m}=\alpha\)</span>；而若<span class="math inline">\(k\)</span>在表<span class="math inline">\(T\)</span>中，则至少它本身在索引为<span class="math inline">\(h(k)\)</span>的bucket中，其他<span class="math inline">\(n-1\)</span>个元素同前一种情况，故长度期望不大于<span class="math inline">\(1+\frac{n-1}{m}\leq 1+\alpha\)</span>。对于任意一个<span class="math inline">\(k\)</span>，不是情况1就是情况2，两种情况下对于bucket的长度的期望都小于<span class="math inline">\(1+\alpha\)</span>，因而对于<span class="math inline">\(k\)</span>的所有可能取值取期望，也一定不大于<span class="math inline">\(1+\alpha\)</span>。当<span class="math inline">\(\alpha=O(1)\)</span>，即表T没有过载（overloaded）时，插入、删除和搜索均在期望意义下均只需要<span class="math inline">\(O(1)\)</span>的时间。</p><h2 id="open-addressing开放地址法"><font color=orange>Open Addressing（开放地址法）</font></h2><p>基本想法是尽可能把空的bucket用起来，当我们想要插入的bucket已经被插入过时，我们就再找一个bucket。为此，哈希函数也要对应升级为二元函数:<br /><img src="https://www.helloimg.com/i/2024/10/26/671c7e0435df5.png" /><br />这里的probe number是在插入<span class="math inline">\(key\)</span>时的搜寻次数，至大不超过<span class="math inline">\(m-1\)</span>。有一些细节需要注意，假设对于key值为123的节点，我们在插入时首先计算<span class="math inline">\(index=h(123,0)\)</span>，发现位置已被key值为456的节点占用，再计算<span class="math inline">\(index=h(123,1)\)</span>，若此时位置未被占用，则可直接插入。但是如果中途我们使用了Remove(456)，再进行Search(123)时，首先寻找的是<span class="math inline">\(index=h(123,0)\)</span>的bucket，此时该bucket为空，我们就会误认为表T中不存在<span class="math inline">\(key=123\)</span>的bucket。为此，我们的Remove需要加一个“墓碑标识”（i.e.将该位置置为DEL）来标志该位置是经过删除的。<br /><font color=#F08080 size=4 face="黑体">注意！开放地址法中要求<span class="math inline">\(\alpha\leq 1\)</span>，即<span class="math inline">\(m\geq n\)</span>.</font></p><h3 id="支持操作的实现-3"><font color=brown>支持操作的实现</font></h3><h4 id="ohashinserttx"><span class="math inline">\(1^o\)</span>HashInsert(T,x)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">HashInsert(T,k):<br>    i=<span class="hljs-number">0</span><br>    repeat<br>    j=h(k,i)<br>    <span class="hljs-keyword">if</span> (T[j]==NIL or T[j]==DEL)<br>        T[j]=k<br>        <span class="hljs-keyword">return</span> j<br>    <span class="hljs-keyword">else</span> i=i+<span class="hljs-number">1</span><br>    until (i==m)<br>    <span class="hljs-keyword">return</span> “overflow”<br></code></pre></td></tr></table></figure><h4 id="ohashsearchtk"><span class="math inline">\(2^o\)</span>HashSearch(T,k)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">HashSearch(T,k):<br>    i=<span class="hljs-number">0</span><br>    repeat<br>    j=h(k,i)<br>    <span class="hljs-keyword">if</span> (T[j]==k)<br>        <span class="hljs-keyword">return</span> j<br>    i=i+<span class="hljs-number">1</span><br>    until (i==m or T[j]==NIL)<br>    <span class="hljs-keyword">return</span> NIL<br></code></pre></td></tr></table></figure><h4 id="ohashremovetx"><span class="math inline">\(3^o\)</span>HashRemove(T,x)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">HashRemove(T,k):<br>    pos=HashSearch(T,k)<br>    <span class="hljs-keyword">if</span> (pos!=NIL)<br>    T[pos]=DEL  <br>    <span class="hljs-keyword">return</span> pos  <br></code></pre></td></tr></table></figure><h3 id="针对搜寻方式的讨论"><font color=brown>针对搜寻方式的讨论</font></h3><p>主要是三种，Linear Probing（线性搜寻）,Quadratic Probing（平方搜寻）以及Double Probing（双哈希搜寻）。<br />Linear Probing这样定义哈希函数：<span class="math inline">\(h(k,i)=(h_1(k)+i)~\mathbf{mod}~m\)</span>，这里<span class="math inline">\(h_1(k)\)</span>是一个一元哈希函数，用以辅助<span class="math inline">\(h(k,i)\)</span>计算的。线性搜寻会引发一个堆积(clustering)的问题，如下图：<br /><img src="https://www.helloimg.com/i/2024/10/27/671d9d0ad7e92.png" /><br />在这种情况下，假设新的key插入每个bucket的概率独立且相等，那么插入索引为0，1，2，7，8的概率均为<span class="math inline">\(\frac{1}{9}\)</span>，而插入索引为6的bucket的概率为<span class="math inline">\(\frac{4}{9}\)</span>，大于其他空bucket。这是因为索引为3，4，5的bucket均已被插入，因而插入它们时都会再找寻相邻的下一个bucket，到了6才会终止。如此，相邻的被插入的bucket就会越来越多，凑成一个堆积成簇的结构，最终导致搜索效率降低。<br />Quadratic Probing与线性搜寻区别不大，而且也会出现堆积问题，只是堆积成簇的结构不会在视觉上是紧密相连的多个bucket。它的哈希函数是：<span class="math inline">\(h(k,i)=(h_1(k)+c_1i+c_2i^2)\mathbf{mod}m\)</span><br />Double Probing可以做到更好的“随机性”，它这样定义哈希函数：<span class="math inline">\(h(k,i)=(h_1(k)+i·h_2(k))\mathbf{mod}m\)</span> 它的优点在于，当<span class="math inline">\(h_1\)</span>选取恰当时，<span class="math inline">\(h(k,0)\)</span>，即给定的key值的初始位置，是较为随机的；当<span class="math inline">\(h_2\)</span>选取恰当时，搜寻的顺序是较为随机的。<br /><br> 下面分析时空复杂度。首先有以下假设:<br /><font color=#F08080 size=6 face="黑体">Uniform Hashing Assumption</font></p><ul><li><font color=#F08080 size=4 face="黑体">The probe sequence of each key is equally likely to be any of the m! permutations of ⟨0,1,…,m−1⟩.</font></li></ul><p>上面三种搜寻方式都无法满足该假设，但是double probing表现得更好。</p><ul><li>不成功搜索的时间复杂度期望为<span class="math inline">\(\mathbf{E[x]}\leq \frac{1}{1-\alpha}\)</span>（这里<span class="math inline">\(\alpha&lt;1\)</span>）</li></ul><p>记事件<span class="math inline">\(A_i\)</span>为第<span class="math inline">\(i\)</span>次搜寻到的bucket是被占用的bucket。<br />现在有m个bucket，其中有n个已经被占有。由于对于每个特定的key而言，其搜寻序列都等可能地是&lt;0,1,...,m-1&gt;的任意一个排列，所以第<span class="math inline">\(i\)</span>次搜寻时不会再搜到前<span class="math inline">\(i-1\)</span>次被搜到的已被占有的bucket。因而有以下推理：</p><p><img src="https://www.helloimg.com/i/2024/10/30/67219e2d2fd7d.png" /></p><ul><li>成功搜索的时间复杂度期望为<span class="math inline">\(\mathbf{E[x]}\leq \frac{1}{\alpha}ln(\frac{1}{1-\alpha})\)</span>（这里<span class="math inline">\(\alpha&lt;1\)</span>）</li></ul><p>记变量<span class="math inline">\(N_i\)</span>为搜索<span class="math inline">\(n\)</span>个已插入的key中第<span class="math inline">\(i\)</span>个插入的key时需要搜寻的次数的期望，<font color=#F08080 size=4 face="黑体">注意到key的搜寻序列和key插入时的搜寻序列是一样的！</font>这相当于在一个有<span class="math inline">\(m\)</span>个bucket的哈希表中已经有<span class="math inline">\(i-1\)</span>个bucket被占据，由前面不成功搜索的推理，此时不成功搜索的次数的期望为即为<span class="math inline">\(N_i\leq\frac{1}{1-\frac{i-1}{m}}\)</span>，进而有以下推理：<br /><img src="https://www.helloimg.com/i/2024/10/30/6721ab94974aa.png" /> 这里关于积分和求和的不等式结合画图就可以推出，对于单增数列和单减数列有类似的推论。</p><p>对于链地址法和开放地址法，有以下优缺点对比：开放地址法无需新的内存分配（链地址法需要给每个bucket额外加装链表节点），并且在存储中是连续的（毕竟不需要链表了）。然而缺点在于对哈希函数的选取比较敏感（堆积（clustering）现象普遍存在，且在选取的哈希函数不佳时尤其严重），而且对装载因子敏感，<span class="math inline">\(\alpha\)</span>趋近于1时表现较差。</p><h2 id="静态情况下的搜索"><font color=orange>静态情况下的搜索</font></h2><p>上面两种方法的搜索开支都是在满足某个假设(Simple Uniform Hashing Assumption&amp;Uniform Hashing Assumption)的前提下，当装载因子<span class="math inline">\(\alpha=O(1)\)</span>时期望时间复杂度为<span class="math inline">\(O(1)\)</span>，但是当我们无需对key进行插入和删除时，我们就只需要进行静态情况下的搜索，此时可以做到最坏情况下的<span class="math inline">\(O(1)\)</span>的搜索开支。</p><p>回忆下哈希函数族：<img src="https://www.helloimg.com/i/2024/10/26/671c6a0ba6b0f.png" /><br />当取<span class="math inline">\(m=n^2\)</span>时，碰撞次数的期望满足<span class="math inline">\(\mathbb{E[\text{numbers of collisions}]\leq (^n_2)\times\frac{1}{m}\leq\frac{1}{2}}\)</span>.这里根据上课讲的一个神奇不等式可以证明我们可以以极高概率构造出来一个没有碰撞(collision)的哈希表，具体的我忘了......等我问一手同学quq<br />这可以成为&quot;Perfect Hashing&quot;，美中不足的是需要占用<span class="math inline">\(\Theta(n^2)\)</span>的空间复杂度。我们对此的解决方案是在每个bucket内部再建一个哈希表，如下：<br /><img src="https://www.helloimg.com/i/2024/10/30/67223fa59f089.png" /> 首先从哈希函数族<span class="math inline">\(H_{pm}\)</span>中随机挑出一个哈希函数<span class="math inline">\(h_{ab}\)</span>来建立一级哈希表（这里<span class="math inline">\(m=n\)</span>），并将<span class="math inline">\(n\)</span>个key先按照链地址法插入，记第<span class="math inline">\(j\)</span>个bucket存放有<span class="math inline">\(n_j\)</span>个键值，随后对于每个非空的bucket，从<span class="math inline">\(H_{pm_j}\)</span>中随机挑出一个哈希函数<span class="math inline">\(h_{a_jb_j}\)</span>来在此处的bucket（索引为<span class="math inline">\(j\)</span>）建立二级哈希表（记为<span class="math inline">\(T_j\)</span>），将此处的bucket的原有链表中的键值全部映射至二级哈希表中，二级哈希表拥有的bucket数量记为<span class="math inline">\(m_j\)</span>，且满足<span class="math inline">\(m_j=n_j\)</span>。对于一级哈希表下的每个非空的bucket，重复随机挑选哈希函数和建立二级哈希表直至不存在碰撞为止（刚才的推论已经保证了找到不存在碰撞的哈希函数并不困难）。<br />下面分析其空间复杂度，即<span class="math inline">\(\sum\limits^{m-1}_{j=0}n_j^2\)</span>.<br />手懒直接粘证明过程（bushi） <img src="https://www.helloimg.com/i/2024/10/30/67224043cf540.png" /></p><p>如此，我们就得到了以下表格：<br /><img src="https://www.helloimg.com/i/2024/10/30/67224075a7684.png" /></p><h1 id="disjoint-sets并查集"><font color=orange>Disjoint Sets（并查集）</font></h1>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构与算法分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>铺垫</title>
    <link href="/2024/10/19/%E9%93%BA%E5%9E%AB/"/>
    <url>/2024/10/19/%E9%93%BA%E5%9E%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="函数的增长">函数的增长</h1><h2 id="渐进记号">渐进记号</h2><h3 id="theta记号"><span class="math inline">\(\Theta\)</span>记号</h3><p><span class="math display">\[\Theta(g(n))=\{f(n)|\exists c_1,c_2,n_0&gt;0~~s.t.~~\forall n\geq n_0,0\leq c_1g(n)\leq f(n)\leq c_2g(n)\}\]</span><br />注意，以上定义要求对<span class="math inline">\(\forall f(n)\in \Theta(g(n))\)</span>，<span class="math inline">\(f(n)\)</span>应当是渐进非负的，即<span class="math inline">\(n\)</span>足够大时，<span class="math inline">\(f(n)\)</span>是非负的。对于满足以上条件的<span class="math inline">\(f(n)\)</span>,我们称<span class="math inline">\(g(n)\)</span>是<span class="math inline">\(f(n)\)</span>的一个<strong>渐进紧确界</strong>。</p><h3 id="o记号渐进上界"><span class="math inline">\(O\)</span>记号（渐进上界）</h3><p><span class="math display">\[O(g(n))=\{f(n)|\exists c,n_0&gt;0~~s.t.~~\forall n\geq n_0,0\leq f(n)\leq cg(n)\}\]</span><br /><span class="math inline">\(O\)</span>记号用以描述渐近上界，对于一个算法的时间复杂度而言，当我们说一个算法的时间复杂度为<span class="math inline">\(O(g(n))\)</span>时，我们说的是存在一个<span class="math inline">\(O(g(n))\)</span>的函数<span class="math inline">\(f(n)\)</span>，不管选定怎样的规模为<span class="math inline">\(n\)</span>的输入，<span class="math inline">\(f(n)\)</span>都是运行时间的一个上界。</p><h3 id="omega记号渐进下界"><span class="math inline">\(\Omega\)</span>记号（渐进下界）</h3><p><span class="math display">\[\Omega(g(n))=\{f(n)|\exists c,n_0~~s.t.\forall n\geq n_0,0\geq cg(n)\geq f(n)\}  \]</span> <span class="math inline">\(\Omega\)</span>记号用以描述渐近下界，当我们说一个算法的渐近下界为<span class="math inline">\(\Omega(g(n))\)</span>时，指的是对任意输入，运行时间不会少于一个<span class="math inline">\(\Omega(g(n))\)</span>的<span class="math inline">\(f(n)\)</span>。<br />由此不难得到一个很显然的推论：</p><blockquote><p><strong>T.H.</strong> <span class="math display">\[\forall f(n),g(n),~~f(n)=\Theta(g(n))\iff f(n)=O(g(n))~and~f(n)=\Omega(g(n))  \]</span></p><hr /></blockquote><p><font color=#9370D8 size=3 face="宋体">似乎比起<span class="math inline">\(f(n)=O(g(n))\)</span>，使用<span class="math inline">\(f(n)\in O(g(n))\)</span>更合适？但是书上确实是用的等于，应该也是为了方便平时推导时间复杂度罢（确信）</font><br /><br> <font color=#F08080 size=3 face="黑体">补：在后面“等式和不等式中的渐近符号”中确实提到了使用等号代替集合论属于符号的好处。</font></p><h3 id="o记号非渐近紧确上界"><span class="math inline">\(o\)</span>记号（非渐近紧确上界）</h3><p><span class="math display">\[o(g(n))=\{f(n)|\forall c&gt;0,\exists n_0&gt;0~~s.t.~~\forall n\geq n_0,0\leq f(n)&lt;cg(n)\}\]</span><br />注意这里的常数<span class="math inline">\(c\)</span>是任取的，因而尽管<span class="math inline">\(2n^2=O(n^2)\)</span>，但是<span class="math inline">\(2n^2\neq o(n^2)\)</span>.有些书中将<span class="math inline">\(o\)</span>记号定义为<span class="math inline">\(\lim\limits_{n\rightarrow+\infty}\frac{f(n)}{g(n)}=0\)</span>.</p><h3 id="omega记号非渐近紧确下界"><span class="math inline">\(\omega\)</span>记号（非渐近紧确下界）</h3><p><span class="math display">\[\omega(g(n))=\{f(n)|\forall c&gt;0,\exists n_0&gt;0,~~s.t.~~\forall n\geq n_0,0\leq cg(n)&lt;f(n)\}  \]</span><br />相应地也可以用极限表示为<span class="math inline">\(\lim\limits_{n\rightarrow+\infty}\frac{f(n)}{g(n)}=\infty\)</span></p><h2 id="主定理">主定理</h2><blockquote><p><strong>T.H.</strong><br />若函数<span class="math inline">\(T(n)\)</span>满足以下递推关系：<br /><span class="math display">\[T(n)=\left\{\begin{array}{ll}\Theta(1)&amp; \text{if }~n=1\\aT(\frac{n}{b})+f(n)&amp;\text{if }~n=b^i\end{array}\right. \]</span> 若<span class="math inline">\(a\geq 1,b&gt;1\)</span>，且<span class="math inline">\(f(n)\)</span>为定义在<span class="math inline">\(b\)</span>的幂上的非负函数，则有<br /><span class="math display">\[T(n)=\Theta(n^{log_ba})+\sum\limits_{j=0}^{log_bn-1}a^jf(\frac{n}{b^j})  ~~~~~~~~\mathbb{(1)}\]</span> 进一步地，有如下渐近界：<br />1.若对某个常数<span class="math inline">\(\epsilon&gt;0\)</span>有<span class="math inline">\(f(n)=O(n^{log_ba-\epsilon})\)</span>，则<span class="math inline">\(T(n)=\Theta(n^{log_ba})\)</span>;<br />2.若<span class="math inline">\(f(n)=\Theta(n^{log_ba})\)</span>，则<span class="math inline">\(T(n)=\Theta(n^{log_ba}lgn)\)</span>;<br />3.若对某个常数<span class="math inline">\(\epsilon&gt;0\)</span>，有<span class="math inline">\(f(n)=\Omega(n^{log_ba+\epsilon})\)</span>，且对某个常数<span class="math inline">\(c&lt;1\)</span>和所有足够大的<span class="math inline">\(n\)</span>有<span class="math inline">\(af(\frac{n}{b})\leq cf(n)\)</span>，则<span class="math inline">\(T(n)=\Theta(f(n))\)</span>。</p><hr /></blockquote><p><font color=#B0C4DE size=4 face="黑体">proof:<br />(1)式用递推树或者直接思考都是易得的。后面三种情况其实是在讨论<span class="math inline">\(\sum\limits_{j=0}^{log_bn-1}a^jf(\frac{n}{b^i})\)</span>的渐近界。<br />对于第一种情况，有<br /><span class="math display">\[\begin{align*}\sum\limits_{j=0}^{log_bn-1}a^jf(\frac{n}{b^j})&amp;=O(\sum\limits_{j=0}^{log_bn-1}a^j(\frac{n}{b^j})^{log_ba-\epsilon})=O(n^{log_ba-\epsilon}\sum\limits_{j=0}^{log_bn-1}(\frac{ab^\epsilon}{b^{log_ba}})^j)\\&amp;=O(n^{log_ba-\epsilon}\frac{n^\epsilon-1}{b^\epsilon-1})=O(n^{log_ba})\end{align*}\]</span> 因而<span class="math inline">\(T(n)=\Theta(n^{log_ba})+O(n^{log_ba})=\Theta(n^{log_ba})\)</span>.<br /><br> 对于第二种情况，只需要在前一种情况的推导过程中使用等比数列前的最后一步把<span class="math inline">\(\epsilon=0\)</span>代入并在其基础上继续推导即可：<br /><span class="math display">\[\begin{align*}\sum\limits_{j=0}^{log_bn-1}a^jf(\frac{n}{b^j})&amp;=\Theta(\sum\limits_{j=0}^{log_bn-1}a^j(\frac{n}{b^j})^{log_ba})\\&amp;=\Theta(n^{log_ba}\sum\limits_{j=0}^{log_bn-1}(\frac{a}{b^{log_ba}})^j)\\&amp;=\Theta(n^{log_ba}log_bn)\end{align*}\]</span> 因而<span class="math inline">\(T(n)=\Theta(n^{log_ba})+\Theta(n^{log_ba}log_bn)=\Theta(n^{log_ba}log_bn)\)</span>.<br /><br></p><p>对于第三种情况，由于<span class="math inline">\(af(\frac{n}{b})\leq cf(n)\)</span>，故<span class="math inline">\(f(\frac{n}{b})\leq (\frac{c}{a})f(n)\)</span>，进而有<span class="math inline">\(f(\frac{n}{b^j})\leq (\frac{c}{a})^jf(n)\)</span>，亦即<span class="math inline">\(a^jf(\frac{n}{b^j})\leq c^jf(n)\)</span>.因此，我们有:<br /><span class="math display">\[\begin{align*}\sum\limits_{j=0}^{log_bn-1}a^jf(\frac{n}{b^j})\leq O(1)+\sum\limits_{j=0}^{log_bn-1}c^jf(n)\leq O(1)+f(n)\sum\limits_{j=0}^{\infty}c^j\leq \frac{f(n)}{1-c}+O(1)=O(f(n))  \end{align*}\]</span> 同时由于<span class="math inline">\(\sum\limits_{j=0}^{log_bn-1}a^jf(\frac{n}{b^j})\geq a^jf(\frac{n}{b^j})|_{j=0}=f(n)\)</span>,故<span class="math inline">\(g(n)=\Omega(f(n))\)</span>，所以<span class="math inline">\(g(n)=\Theta f(n)\)</span>.<br />因而<span class="math inline">\(T(n)=\Theta(n^{log_ba})+\Theta(f(n))=\Theta(f(n))\)</span>，注意此情况的前提条件中给出了<span class="math inline">\(f(n)=\Omega(n^{log_ba+\epsilon})\)</span> </font></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构与算法分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>连续型随机变量</title>
    <link href="/2024/10/18/%E8%BF%9E%E7%BB%AD%E6%80%A7%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/"/>
    <url>/2024/10/18/%E8%BF%9E%E7%BB%AD%E6%80%A7%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="连续型随机变量">连续型随机变量</h1><h2 id="期望">期望</h2><h3 id="非负随机变量x">非负随机变量X</h3><p><font color=#9370D8 size=4 face="黑体">T.H.对于非负随机变量X，有<span class="math display">\[  E[X]=\int_0^{+\infty}P(X&gt;t)dt\\\]</span><br /></font></p><p><font color=#B0C4DE size=4 face="黑体">proof: <span class="math display">\[  \begin{align*}E[x] &amp; =\int_0^{+\infty}xf(x)dx\\&amp; =\int_0^{+\infty}(\int_0^{x}I[t\leq x]dt+\int_{x}^{+\infty}I[t\leq x]dt)f(x)dx\\&amp; =\int_0^{+\infty}\int_0^{+\infty}I[t\leq x]f(x)dtdx\\&amp; =\int_0^{+\infty}dt\int_0^{+\infty}I[t\leq x]f(x)dx\\&amp; =\int_0^{+\infty}dt\int_t^{+\infty}f(x)dx \\&amp; =\int_0^{+\infty}p(X\geq t)dt \end{align*}\]</span><br /></font></p><blockquote><p><strong>复习一下求导</strong><br /><span class="math inline">\(F(t)=P(X\leq t)\)</span>为分布函数，<span class="math inline">\(f(x)\)</span>为概率密度函数。<br />对函数 <span class="math display">\[  \begin{align*}h(t)&amp;=\int_0^{t}(t-x)cf(x)dx+\int_t^{+\infty}(x-t)Cf(x)dx\\\end{align*}\]</span><br />第一项求导为<span class="math inline">\(cF(t)+ctf(t)-ctf(t)=cF(t)\)</span><br />第二项求导为：<br /><span class="math display">\[\begin{align*}原式&amp;=(\int_t^{+\infty}(x-t)Cf(x)dx)^{&#39;}\\&amp;=C(\int_t^{+\infty}xf(x)dx)^{&#39;}-C(\int_t^{+\infty}tf(x)dx)^{&#39;}\\&amp;=C(-tf(t))-Ct(\int_t^{+\infty}f(x)dx)^{&#39;}-C\int_t^{+\infty}f(x)dx\\&amp;=-Ctf(t)-Ct(1-F(t))^{&#39;}-C(1-F(t))\\&amp;=-Ctf(t)+Ctf(t)-C(1-F(t))\\&amp;=CF(t)-C\end{align*}\]</span> 故h(t)求导为<span class="math inline">\(h^{&#39;}(t)=(c+C)F(t)-C\)</span></p><hr /></blockquote><h2 id="常用连续分布">常用连续分布</h2><p>判断一个分布是否是连续分布，需要检查其规范性和非负性。</p><h3 id="均匀分布">均匀分布</h3><h3 id="指数分布">指数分布</h3><p>给定常数<span class="math inline">\(\lambda&gt;0\)</span>，若随机变量X的概率密度函数 <span class="math display">\[f(x) = \left\{\begin{array}{ll}\lambda e^{-\lambda x} &amp; \text{if } x \geq 0 \\0 &amp; \text{if } 其他\end{array}\right.\]</span><br />则称X服从参数为<span class="math inline">\(\lambda\)</span>的指数分布，记为<span class="math inline">\(X\sim e(\lambda)\)</span>.<br />进而易得分布函数<br /><span class="math display">\[F(x) = \left\{\begin{array}{ll}\int_0^x\lambda e^{-\lambda t}dt=1-e^{-\lambda x}&amp; \text{if } x &gt; 0 \\0 &amp; \text{if } 其他\end{array}\right.\]</span></p><p><br><br /><br><br /><font color=#F08080 size=6 face="黑体">指数分布是唯一具有无记忆性的连续型随机变量</font></p><p><font color=#B0C4DE size=4 face="黑体">proof: <span class="math display">\[\begin{align*}&amp;F(x)=1-e^{-\lambda x}=P(X\leq x)\\&amp;P(X&gt;x)=e^{-\lambda x}\\&amp;P(X.s+t|x&gt;t)=\frac{P(X&gt;s+t)}{P(x&gt;t)}=\frac{e^{-\lambda (s+t)}}{e^{-\lambda t}}=e^{-\lambda s}=P(X&gt;s).\\\end{align*}\]</span> </font></p><h3 id="正态分布">正态分布</h3><p>给定<span class="math inline">\(u\in(-\infty,+\infty)\)</span>和<span class="math inline">\(\sigma&gt;0\)</span>，若随机变量<span class="math inline">\(X\)</span>的概率密度为<br /><span class="math display">\[  f(x)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma ^2}},x\in(-\infty,+\infty)\]</span><br />则称<span class="math inline">\(X\)</span>服从参数为<span class="math inline">\(\mu,\sigma^2\)</span>的正态分布，记为<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>.<br />特别地，若<span class="math inline">\(\mu=0\)</span>和<span class="math inline">\(\sigma=1\)</span>，则称<span class="math inline">\(N(0,1)\)</span>为标准正态分布，此时密度函数为<span class="math inline">\(f(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}\)</span></p>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RTFSC</title>
    <link href="/2024/10/15/RTFSC/"/>
    <url>/2024/10/15/RTFSC/</url>
    
    <content type="html"><![CDATA[<h1 id="pa2"><font color=orange>PA2</font></h1><h2 id="mtrace"><font color=brown>mtrace</font></h2><p>  在~/ics2024/am-kernels/tests/cpu-tests/build中运行指令riscv64-linux-gnu-readelf -a add-riscv32-nemu.elf，即可查看其对应的符号表。   在.c中找到parse_args函数，在里面添加关于elf读入的设置，</p><h2 id="时钟"><font color=brown>时钟</font></h2><p>  在ics2024/abstract-machine/am/src/riscv/riscv.h中定义了inl用以取出32位无符号整数，联系gitbook中提到时钟是 <strong>“计时器初始化时会分别注册0x48处长度为8个字节的端口, 以及0xa0000048处长度为8字节的MMIO空间, 它们都会映射到两个32位的RTC寄存器. CPU可以访问这两个寄存器来获得用64位表示的当前时间.”</strong>，因而这个就是用以取32位寄存器的。<br />  而在ics2024/abstract-machine /am /src /platform /nemu /include/nemu.h中定义的RTC_ADDR就是实时时钟RTC的地址了。</p><h2 id="跑分测试"><font color=brown>跑分测试</font></h2><p>  出了点小插曲后吓得赶紧留了个快照，不过快照留了有点匆忙，忘了把printf()实现中的putch('a')注释掉了，下次用的时候得注意了......(不过希望我永远也不需要再回退回来罢quq)<br />  在menu文件夹下运行指令 <figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs make">make menuconfig<br></code></pre></td></tr></table></figure></p><blockquote><p><strong>总是会遗忘</strong></p><ul><li>如果想要在NEMU中配置一些可供选择开启与否的宏，可以在ics2024/nemu/Kconfig中添加相关定义。注意，在Kconfig中定义的名字，实际生成的宏是会加&quot;CONFIG_&quot;前缀的。比如我在Kconfig中添加MTRACE的定义，那么实际定义出来的宏是CONFIG_MTRACE。</li></ul><hr /></blockquote><h1 id="一些关于抽象层的理解">一些关于抽象层的理解</h1><p>背景是首先看到了gitbook上的<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2024/2.3.html#%E5%B0%86%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83%E5%B0%81%E8%A3%85%E6%88%90%E5%BA%93%E5%87%BD%E6%95%B0">内容直达</a>讨论的关于n+m和n*m的问题，又看到了gitbook上的<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2024/2.3.html#%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E4%B8%AA%E6%8A%BD%E8%B1%A1%E5%B1%82">内容直达</a>，所以决定整理一下。<br />在实现klib的printf时，输出单个字符用的是putch()。进行RTFSC，可以看到就如gitbook所说，不同的平台(platform)实现putch不完全一样。在native上，直接用的putchar()函数；而我们亲爱的NEMU（笑）用的是outb()函数，而outb()函数在不同的指令集(ISA)上有不同的定义，如在riscv.h,mips.h,loongarch32.h中都定义为<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">outb</span><span class="hljs-params">(<span class="hljs-type">uintptr_t</span> addr, <span class="hljs-type">uint8_t</span>  data)</span> &#123; *(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span>  *)addr = data; &#125;  <br></code></pre></td></tr></table></figure></p><p>而在x86.h中定义为<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">outb</span><span class="hljs-params">(<span class="hljs-type">int</span> port, <span class="hljs-type">uint8_t</span> data)</span> &#123;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;outb %%al, %%dx&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span>(data), <span class="hljs-string">&quot;d&quot;</span>((<span class="hljs-type">uint16_t</span>)port))</span>;<br>&#125;  <br></code></pre></td></tr></table></figure></p><p>而outb仅仅是用以把字符串写入串口的，最终把字符串打印到终端的工作是由NEMU中的serial_io_handler()承担。它的定义如下：<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">serial_io_handler</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> offset, <span class="hljs-type">int</span> len, <span class="hljs-type">bool</span> is_write)</span> &#123;<br>  assert(len == <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">switch</span> (offset) &#123;<br>    <span class="hljs-comment">/* We bind the serial port with the host stderr in NEMU. */</span><br>    <span class="hljs-keyword">case</span> CH_OFFSET:<br>      <span class="hljs-keyword">if</span> (is_write) serial_putc(serial_base[<span class="hljs-number">0</span>]);<br>      <span class="hljs-keyword">else</span> panic(<span class="hljs-string">&quot;do not support read&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: panic(<span class="hljs-string">&quot;do not support offset = %d&quot;</span>, offset);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 由此，库函数中但凡需要打印字符的，均使用每次打印单个字符的putch()，无论平台；不同的平台（也即模拟器），均实现自己的putch()函数，并在和各个指令集接洽的处理手段上解决实现putch()所依赖的行为在具体指令中的处理(NEMU中实现putch()依赖的正是outb()函数。)</p><h1 id="pa3"><font color=orange>PA3</font></h1><h2 id="trap.s"><font color=brown>trap.S</font></h2><p>源于<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2024/3.2.html#%E4%BF%9D%E5%AD%98%E4%B8%8A%E4%B8%8B%E6%96%87">这个子标题下的第二道必答题及其下面的绿框提示</a><br />我一开感到相当困惑的一点是汇编文件trap.S中的内容是如何被其他地方用上的，仔细研究后有如下收获：<br />trap.S(路径为abstract-machine/am/src/riscv/nemu/trap.S)中的这块代码是在定义一个可以被其他文件调用的函数：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs S">.globl __am_asm_trap<br>__am_asm_trap:<br>  addi sp, sp, -CONTEXT_SIZE<br><br>  MAP(REGS, PUSH)<br><br>  csrr t0, mcause<br>  csrr t1, mstatus<br>  csrr t2, mepc<br><br>  STORE t0, OFFSET_CAUSE(sp)<br>  STORE t1, OFFSET_STATUS(sp)<br>  STORE t2, OFFSET_EPC(sp)<br><br>  # set mstatus.MPRV to pass difftest<br>  li a0, (1 &lt;&lt; 17)<br>  or t1, t1, a0<br>  csrw mstatus, t1<br><br>  mv a0, sp<br>  call __am_irq_handle<br><br>  LOAD t1, OFFSET_STATUS(sp)<br>  LOAD t2, OFFSET_EPC(sp)<br>  csrw mstatus, t1<br>  csrw mepc, t2<br><br>  MAP(REGS, POP)<br><br>  addi sp, sp, CONTEXT_SIZE<br>  mret<br></code></pre></td></tr></table></figure> 而在cte.c(路径为abstract-machine/am/src/riscv/nemu/cte.c)中，用到了这个函数：<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> __am_asm_trap(<span class="hljs-type">void</span>);<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">cte_init</span><span class="hljs-params">(Context*(*handler)(Event, Context*))</span> &#123;<br>  <span class="hljs-comment">// initialize exception entry</span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;csrw mtvec, %0&quot;</span> : : <span class="hljs-string">&quot;r&quot;</span>(__am_asm_trap))</span>;<br><br>  <span class="hljs-comment">// register event handler</span><br>  user_handler = handler;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 这里将 __am_asm_trap 函数的地址写入到 RISC-V 的 mtvec 控制状态寄存器中。 这样，在中断发生时，处理器就会跳转到 __am_asm_trap 函数，从而处理相应的中断或异常。</p><p>我还有一个困惑的地方是既然传入__am_irq_handle的参数是指向结构体的指针，那么调用参数都是类似关键词调用参数(如c-&gt;mcause)，怎么会和结构体定义的顺序有关呢？后来发现在trap.S中定义__am_asm_trap函数时调用了__am_irq_handle函数：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs s">call __am_irq_handle<br></code></pre></td></tr></table></figure> 那么这时在调用的时候__am_irq_handle获得的参数显然是根据汇编中对寄存器或者栈的操作来获取的，而在调用它前，有以下操作：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs S">addi sp, sp, -CONTEXT_SIZE<br><br>MAP(REGS, PUSH)<br><br>csrr t0, mcause<br>csrr t1, mstatus<br>csrr t2, mepc<br><br>STORE t0, OFFSET_CAUSE(sp)<br>STORE t1, OFFSET_STATUS(sp)<br>STORE t2, OFFSET_EPC(sp)<br></code></pre></td></tr></table></figure> 这正是将寄存器以及CSR中存放的数据压入栈中的操作，但是这意味着先压入寄存器，再压入mcause、mstatus和mepc吗？并不是！！！在trap.S文件一开始有以下宏定义：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs s">#define REGS(f) REGS_LO16(f) REGS_HI16(f)<br><br>#define PUSH(n) STORE concat(x, n), (n * XLEN)(sp);<br>#define POP(n)  LOAD  concat(x, n), (n * XLEN)(sp);<br><br>#define CONTEXT_SIZE  ((NR_REGS + 3) * XLEN)<br>#define OFFSET_SP     ( 2 * XLEN)<br>#define OFFSET_CAUSE  ((NR_REGS + 0) * XLEN)<br>#define OFFSET_STATUS ((NR_REGS + 1) * XLEN)<br>#define OFFSET_EPC    ((NR_REGS + 2) * XLEN)<br></code></pre></td></tr></table></figure> 所以，真实过程如下：假定sp旧值为old_sp，context占用空间为size，那么sp新值为old_sp-size，而紧接着sp的旧值的是mepc，因为宏OFFSET_EPC中规定了它在sp新值上方(NR_REGS+2)*XLEN个地方，正好就是sp的旧值的下一个单元，这就相当于是先将mepc压入栈，其他以此类推，所以压入栈后各参数地址从高到低依次为：</p><blockquote><p>mepc<br />mstatus<br />mcause<br />gpr[31]<br />...<br />gpr[0]</p><hr /></blockquote><p>又使用了下面的指令来获取参数：<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs S">mv a0, sp             # 将栈指针 sp 的值移动到 a0 中，作为传入参数<br></code></pre></td></tr></table></figure> 这样一来，在riscv.h(路径为abstract-machine/am/include/arch/riscv.h)中定义的Context结构体的参数顺序就有关系了，因为是反向压栈的，因而就是如下定义:<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Context</span> &#123;</span><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> fix the order of these members to match trap.S</span><br>  <span class="hljs-type">uintptr_t</span> gpr[NR_REGS], mcause, mstatus, mepc;<br>  <span class="hljs-type">void</span> *pdir;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h1 id="框架代码研究"><font color=orange>框架代码研究</font></h1><h2 id="nemu的cpu设计"><font color=brown>NEMU的CPU设计</font></h2><p>在nemu/src/isa/riscv32/include/isa-def.h中定义了相应的寄存器。</p><h1 id="lab2"><font color=orange>Lab2</font></h1><p>首先在setimp.h中不难找到以下定义：<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">JUMP_BUFFER</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">unsigned</span> __int64 Frame;<br>    <span class="hljs-type">unsigned</span> __int64 Rbx;<br>    <span class="hljs-type">unsigned</span> __int64 Rsp;<br>    <span class="hljs-type">unsigned</span> __int64 Rbp;<br>    <span class="hljs-type">unsigned</span> __int64 Rsi;<br>    <span class="hljs-type">unsigned</span> __int64 Rdi;<br>    <span class="hljs-type">unsigned</span> __int64 R12;<br>    <span class="hljs-type">unsigned</span> __int64 R13;<br>    <span class="hljs-type">unsigned</span> __int64 R14;<br>    <span class="hljs-type">unsigned</span> __int64 R15;<br>    <span class="hljs-type">unsigned</span> __int64 Rip;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> MxCsr;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> FpCsr;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> Spare;<br><br>    SETJMP_FLOAT128 Xmm6;<br>    SETJMP_FLOAT128 Xmm7;<br>    SETJMP_FLOAT128 Xmm8;<br>    SETJMP_FLOAT128 Xmm9;<br>    SETJMP_FLOAT128 Xmm10;<br>    SETJMP_FLOAT128 Xmm11;<br>    SETJMP_FLOAT128 Xmm12;<br>    SETJMP_FLOAT128 Xmm13;<br>    SETJMP_FLOAT128 Xmm14;<br>    SETJMP_FLOAT128 Xmm15;<br>&#125; _JUMP_BUFFER;<br></code></pre></td></tr></table></figure> 注意这个是在代码块<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined _M_X64</span><br></code></pre></td></tr></table></figure> 下的，不同的架构对_JUMP_BUFFER的定义不同。Rsp,Rbp是栈顶栈底指针，Rsi,Rdi分别用以存放第一、二个参数到函数，rip常用于存放pc值，至于rbx以及r12-15,可参考下图：<br /><img src="https://www.helloimg.com/i/2024/11/01/6724a82fbf233.png" alt="各寄存器作用" /><br />参考了这个博客<a href="https://blog.csdn.net/dianqicyuyan/article/details/121006913?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522EE7FEC95-9C4E-43E7-B082-C2D4CA498D62%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=EE7FEC95-9C4E-43E7-B082-C2D4CA498D62&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-3-121006913-null-null.nonecase&amp;utm_term=rbx%E5%AF%84%E5%AD%98%E5%99%A8&amp;spm=1018.2226.3001.4450">寄存器的作用整理</a><br />于是就愉快地决定了我们选用以下八个寄存器作为环境状态的存储：rbx,rsp,rbp,r12-15,rip。由于都是64位寄存器，占8个字节，所以定义asm_jump_buf如下：<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint64_t</span> jmp_buf_less[<span class="hljs-number">8</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> asm_jmp_buf jmp_buf_less</span><br></code></pre></td></tr></table></figure> 而setjmp和longjmp的函数头如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span>     <span class="hljs-title function_">asm_setjmp</span><span class="hljs-params">(asm_jmp_buf env)</span>;<br><span class="hljs-type">void</span>    <span class="hljs-title function_">asm_longjmp</span><span class="hljs-params">(asm_jmp_buf env, <span class="hljs-type">int</span> val)</span>;<br></code></pre></td></tr></table></figure> 由于env都是第一个参数，因而在内联汇编语句中各寄存器的实际位置依次是：<br />rbx $~~~~~~<del>$0（%%rdi）<br />rsp $</del>~~~~<del>$8（%%rdi）<br />rbp $</del>~~~<del>$16（%%rdi）<br />r12-r15 $</del>$24-48（%%rdi）<br />rip $~~~~~~~~~$56（%%rdi）<br />最后一个要点是setjmp如何返回合适的值，这个是通过修改eax来实现的，即最后eax寄存器中存放的值才是实际的返回值，而不会因为return 0就导致setjmp一直返回0.实际上，setjmp在首次调用时返回0，在经过longjmp回退时返回longjmp的第二个参数val的值，除非val==0，此时返回1.</p><h1 id="参考资源整理"><font color=orange>参考资源整理</font></h1><p><a href="https://blog.csdn.net/qq_39507748/article/details/120150936?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522FC28BD00-5FDC-4A79-8A0B-4ACB97C40179%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=FC28BD00-5FDC-4A79-8A0B-4ACB97C40179&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-120150936-null-null.nonecase&amp;utm_term=csrrw%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F&amp;spm=1018.2226.3001.4450">RISCV32指令格式</a></p><h1 id="可能的问题"><font color=orange>可能的问题</font></h1><ul><li>nemu32.c 实现的J型立即数，使用BITS与SEXT<br /></li><li>nemu/src/isa/riscv32/inst.c 中，ecall指令的寄存器&quot;a7&quot;</li><li>暂时没有让Difftest支持异常响应机制</li><li>printf使用%x输出十六进制数会存在问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>PA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随机事件与概率，条件概率与独立性，离散型随机变量</title>
    <link href="/2024/10/13/%E5%8F%A4%E5%85%B8%E6%A6%82%E5%9E%8B%E4%B8%8E%E7%A6%BB%E6%95%A3%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/"/>
    <url>/2024/10/13/%E5%8F%A4%E5%85%B8%E6%A6%82%E5%9E%8B%E4%B8%8E%E7%A6%BB%E6%95%A3%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="随机事件与概率">随机事件与概率</h1><h2 id="试验与事件">试验与事件</h2><p>  出现结果不唯一，事先不确定结果的，称为<font color=#F08080 size=4 face="黑体">随机现象</font>；为了研究随机现象的规律<font color=#F08080>（结果的分布）</font>而进行的试验称为<font color=#F08080 size=4 face="黑体">随机试验</font><font color=#B0C4DE size=4 face="黑体">（记为<span class="math inline">\(E\)</span>或<span class="math inline">\(E_i\)</span>）</font>，随机试验具有以下三条性质：</p><ul><li>可重复<br /></li><li>多结果<br /></li><li>不确定</li></ul><p>  随机试验<span class="math inline">\(E\)</span>的每一种可能的结果称为一个<font color=#F08080 size=4 face="黑体">样本点</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(\omega_i~~\)</span></font>. <span class="math inline">\(E\)</span>的所有可能的结果作为元素构成的集合称为<font color=#F08080 size=4 face="黑体">试验<span class="math inline">\(E\)</span>的样本空间</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(\Omega\)</span></font>.样本空间有多种，样本点有限则为<font color=#F08080 size=4>有限样本空间</font>，样本点无限但可列即为<font color=#F08080 size=4 face="黑体">可列样本空间</font>，样本的无线且不可列即为<font color=#F08080 size=4 face="黑体">不可列样本空间</font>。有限样本空间和无限样本空间统称为<font color=#F08080 size=4 face="黑体">离散样本空间</font>。<br />  包含了一些具有相同特性的样本点的集合称为<font color=#F08080 size=4 face="黑体">事件</font>，事件是样本空间的子集。事件也有多种，只包含一个样本点的事件称<font color=#F08080 size=4 face="黑体">基本事件</font>，样本空间<span class="math inline">\(\Omega\)</span>本身称<font color=#F08080 size=4 face="黑体">必然事件</font>，空集<span class="math inline">\(\varnothing\)</span>称<font color=#F08080 size=4 face="黑体">不可能事件</font>。</p><h2 id="事件的关系与运算">事件的关系与运算</h2><p><font color=#9370D8 size=4 face="黑体">1&gt;包含关系</font><br />  对事件A,B，若A发生则必然B发生，则<span class="math inline">\(A\subset B\)</span>.<br /><font color=#9370D8 size=4 face="黑体">2&gt;等于关系</font><br />  若<span class="math inline">\(A\subset B\)</span>且<span class="math inline">\(B\subset A\)</span>,则称<font color=#F08080 size=4 face="黑体">事件A与事件B相等</font>,记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(A=B\)</span></font>。<br /><font color=#9370D8 size=4 face="黑体">3&gt;事件的并/和</font><br />  事件F发生时，若事件<span class="math inline">\(A_1,...,A_n\)</span>中至少有一个发生，则称<font color=#F08080 size=4 face="黑体">事件<span class="math inline">\(F\)</span>为事件<span class="math inline">\(A_i,...,A_n\)</span>的并/和</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(F=\bigcup \limits_{i=1}^{n}A_i=A_1\cup A_2 \cup ... \cup A_n=\{\omega|\exists i\in[n] \hspace{0.2cm} s.t.\hspace{0.2cm}\omega \in A_i\}\)</span></font>.<br /><font color=#9370D8 size=4 face="黑体">4&gt;事件的交/积</font><br />  事件F发生时，若事件<span class="math inline">\(A_1,...,A_n\)</span>全部都发生，则称<font color=#F08080 size=4 face="黑体">事件<span class="math inline">\(F\)</span>为事件<span class="math inline">\(A_i,...,A_n\)</span>的交/积</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(F=\bigcap \limits_{i=1}^{n}A_i=A_1\cap A_2 \cap ... \cap A_n=\{\omega|\forall i\in[n] \hspace{0.2cm} s.t.\hspace{0.2cm}\omega \in A_i\}\)</span></font>.<br /><font color=#9370D8 size=4 face="黑体">5&gt;对立/逆事件</font><br />  所有不属于事件A的基本事件所构成的事件称为<font color=#F08080 size=4 face="黑体">事件A的对立事件（逆事件）</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(\bar{A}=\Omega-A\)</span></font>.<br /><font color=#9370D8 size=4 face="黑体">6&gt;事件的差</font><br />  事件F发生时，若事件<span class="math inline">\(A\)</span>发生且事件<span class="math inline">\(B\)</span>不发生，则称<font color=#F08080 size=4 face="黑体">事件<span class="math inline">\(F\)</span>为事件<span class="math inline">\(A与B\)</span>的差</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(F=A-B=A-AB=A\bar{B}\)</span></font><br /><font color=#9370D8 size=4 face="黑体">7&gt;互不相容/互斥事件</font><br />  若事件<span class="math inline">\(A\)</span>和事件<span class="math inline">\(B\)</span>不能同时发生，则称<font color=#F08080 size=4 face="黑体">事件<span class="math inline">\(A\)</span>与事件<span class="math inline">\(B\)</span>互不相容（互斥）</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(A\cap B=\varnothing\)</span></font>.</p><blockquote><p><strong>会犯错吗？</strong></p><ul><li>如果只有<span class="math inline">\(A-B=A-C\)</span>,那么事件B,C未必满足<span class="math inline">\(B=C\)</span>。</li></ul><hr /></blockquote><blockquote><p><strong><font color=orange size=4>techniques</font></strong></p><ul><li><p>证明两个事件的运算是相等的，我们可以使用瞪眼法，也可以将二者都化为某一特定范式，如BNF或者DNF。</p></li><li><p>e.g.证明<span class="math inline">\((A-B)\cup (B-C)=(A\cup B)-BC\)</span>.<br /><font color=#00ffff size=3 face="黑体">遇到<span class="math inline">\(A-B\)</span>先展开为<span class="math inline">\(A\cap \bar{B}\)</span>，左右两式都化为析取范式，则有:<br />左式=<span class="math inline">\((A\cap \bar{B})\cup(B\cap \bar{C})\)</span><br />右式=<span class="math inline">\((A\cap \bar{B})\cup(B\cap \bar{C})\cup(A\cap\bar{C})\)</span><br />此时右式确实满足析取范式，只是多出来一项冗余项，需要借助语义来证明它可以被前两项的并集包含，进而证明可以去掉冗余项。则：<br /><span class="math inline">\(A\cap \bar{C}=(A\cap\bar{C})\cap(B\cup\bar{B})=(A\cap\bar{C}\cap B)\cup(A\cap \bar{C}\cap\bar{B})\)</span><br />又注意到<span class="math inline">\((A\cap\bar{C}\cap B)\subset(\bar{C}\cap B),(A\cap \bar{C}\cap\bar{B})\subset(A\cap\bar{B})\)</span>,故右式=<span class="math inline">\((A\cap \bar{B})\cup(B\cap \bar{C})\)</span>=左式。 </font></p></li></ul><hr /></blockquote><h2 id="频率与概率公理化">频率与概率公理化</h2><p>  事件<span class="math inline">\(A\)</span>在相同条件下重复进行的<span class="math inline">\(n\)</span>次试验中发生了<span class="math inline">\(n_A\)</span>次，则称<span class="math inline">\(f_n(A)=\frac{n_A}{n}\)</span>为<font color=#F08080 size=4 face="黑体">事件A在n次试验中发生的概率</font>，并称<span class="math inline">\(n_A\)</span>为<font color=#F08080 size=4 face="黑体">事件A发生的频数</font>。<br />  概率的统计定义：<font color=#F08080 size=4 face="黑体">随机事件<span class="math inline">\(A\)</span>在大量重复试验中发生的频率总是稳定在一个常数<span class="math inline">\(p\)</span>附近摆动，且随着试验次数增加而摆幅渐小，则称<span class="math inline">\(p\)</span>为事件<span class="math inline">\(A\)</span>发生的概率</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(P(A)=p\)</span></font><br />  概率公理化定义：<font color=#F08080 size=4 face="黑体">随机试验<span class="math inline">\(E\)</span>所对应的样本空间<span class="math inline">\(\Omega\)</span>中每一个随机事件<span class="math inline">\(A\)</span>，均赋予一实数<span class="math inline">\(P(A)\)</span>，且满足以下条件：<br /><span class="math inline">\(1^o\)</span> 非负性： 对任意事件<span class="math inline">\(A\)</span>有<span class="math inline">\(P(A)\geq0\)</span>；<br /><span class="math inline">\(2^o\)</span> 规范性： 对样本空间<span class="math inline">\(\Omega\)</span>有<span class="math inline">\(P(\Omega)=1\)</span>；<br /><span class="math inline">\(3^o\)</span> 可列可加性： 若<span class="math inline">\(A_1,A_2,...,A_n,...\)</span>是可列无穷个互不相容的事件，即<span class="math inline">\(A_iA_j=\varnothing(i\neq j)\)</span>，有<span class="math inline">\(P(A_1\cup A_2\cup ...\cup A_n\cup...)=P(A_1)+P(A_2)+...+P(A_n)+...\)</span>.<br />   则称<span class="math inline">\(P(A)\)</span>为随机事件<span class="math inline">\(A\)</span>的概率. </font></p><p>  公理化定义中只规定了可列可加性，因而有限可加性是需要我们自己根据公里导出的。这里只证最重要的两条，其他性质主要就是由这两条导出的了。<br /><strong><span class="math inline">\(1^o\)</span> 对不可能事件<span class="math inline">\(\varnothing\)</span>有<span class="math inline">\(P(\varnothing)=0\)</span>.</strong><br />  proof:取<span class="math inline">\(A_i=\varnothing(i=1,2,...)\)</span>,则<span class="math inline">\(A_i\cap A_j=\varnothing(i\neq j)\)</span>.据公理3可得<span class="math inline">\(P(\varnothing)=P(\bigcup \limits_{i=1}^{\infty}A_i)=\sum \limits_{i=1}^{\infty}P(A_i)=\sum \limits_{i=1}^{\infty}P(\varnothing)\)</span>，又由第一条公理非负性，可知<span class="math inline">\(P(\varnothing)=0\)</span>.<br /><strong><span class="math inline">\(2^o\)</span> 有限可加性：若<span class="math inline">\(A_1,A_2,...,A_n\)</span>是两两不相容事件，则<span class="math inline">\(P(\bigcup \limits_{i=1}^{n}A_i)=\sum \limits_{i=1}^{n}P(A_i)\)</span>.</strong><br />  proof:取<span class="math inline">\(A_i=\varnothing(i&gt;n)\)</span>,则<span class="math inline">\(\bigcup\limits_{i=1}^{n}A_i=\bigcup\limits_{i=1}^{\infty}A_i\)</span>.又由扩展后<span class="math inline">\(A_1,A_2,...,A_n,A_{n+1},...\)</span>两两不相容，据公理3可得<span class="math inline">\(P(\bigcup \limits_{i=1}^{n}A_i)=P(\bigcup \limits_{i=1}^{\infty}A_i)=\sum \limits_{i=1}^{n}P(A_i)+\sum \limits_{i=n+1}^{\infty}P(\varnothing)=\sum \limits_{i=1}^{n}P(A_i)\)</span>.</p><p>  <strong>容斥原理推广：</strong><br /><span class="math display">\[P(\bigcup\limits_{i=1}^{n}A_i)=\sum\limits_{r=1}^{n}(-1)^{r+1}\sum\limits_{i_1&lt;...&lt;i_r}P(A_{i_1}\cdots A_{i_r})\]</span></p><p>  <strong>Union Bound:</strong><br /><span class="math display">\[P(A_1\cup A_2\cup\cdots\cup A_n)\leq P(A_1)+P(A_2)+\cdots +P(A_n)\]</span></p><p>  以上两条性质都可以使用归纳法证明。</p><h2 id="古典概型">古典概型</h2><p>  对于满足<span class="math inline">\(1^o\)</span>试验结果仅有有限种可能<span class="math inline">\(2^o\)</span>每种结果等可能地发生 的试验<span class="math inline">\(E\)</span>，称该类试验为<font color=#F08080 size=4 face="黑体">古典概型(等可能概型)</font>。<br />  对于古典概型，有事件<span class="math inline">\(A\)</span>发生的概率为<span class="math inline">\(P(A)=\frac{|A|}{|\Omega|}\)</span>，其中<span class="math inline">\(|A|\)</span>表示事件<span class="math inline">\(A\)</span>包含的<span class="math inline">\(\Omega\)</span>中的基本事件的个数。<br />  一些符号约定： <span class="math display">\[(n)_r=A_n^r=\frac{n!}{(n-r)!}  \]</span> <span class="math display">\[(_r^n)=C_n^r=\frac{n!}{r!(n-r)!}\]</span></p><h2 id="几何概型">几何概型</h2><p>  对于满足<span class="math inline">\(1^o\)</span>样本空间无限且可测<span class="math inline">\(2^o\)</span>基本事件等可能性（每个事件发生概率仅与其几何测度相关而与位置无关） 的试验<span class="math inline">\(E\)</span>，称该类试验为<font color=#F08080 size=4 face="黑体">几何概型</font>。<br />  对于几何概型，有事件<span class="math inline">\(A\)</span>发生的概率为<span class="math inline">\(P(A)=\frac{A的测度}{\Omega的测度}=\frac{\mu(A)}{\mu(\Omega)}\)</span>。</p><h1 id="条件概率与独立性">条件概率与独立性</h1><p>  将事件<span class="math inline">\(A\)</span>发生的条件下事件<span class="math inline">\(B\)</span>发生的概率记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(P(B|A)=\frac{P(AB)}{P(A)}\)</span></font>，注意这要求<span class="math inline">\(P(A)\neq 0\)</span>.<font color=#F08080 size=4 face="黑体">概率为0的事件不一定只有不可能事件哦！</font></p>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/10/13/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/10/13/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="测试一下吧">测试一下吧！</h1><p>测试好了就贴上芙宝的教堂图！！！ <img src="https://www.helloimg.com/i/2024/10/13/670b4eb055555.jpg" alt="极昼机体" /></p>]]></content>
    
    
    <categories>
      
      <category>划水</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/13/hello-world/"/>
    <url>/2024/10/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>划水</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
