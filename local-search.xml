<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>learning0</title>
    <link href="/2024/10/25/learning0/"/>
    <url>/2024/10/25/learning0/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="呀嘞呀嘞，密码不对还想硬闯吗？真是拦不住的大小姐~" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="85cbadc33e839df0355466dcf9ee646de1d6e309d8194b763405ceb4ae8901a9">500036ade4324703080d4b46a2870e61a73fe1d88dbe1acf67cdab44fedecaeda749628525812a8caaa5c3db112688a59dac483073206c2dddd4e4fb73966c4a69d407fcf0e429de2ddad1aa84d1c589a16105b3bb92b0b08c295298313c47754ea02b9d9f7161eb954eca2209b5194d2fd307eeb16be9495ae30e30e578de19efb1c7fe8df5d118c01f62a2e3af088b74ba81bd241e9f2c3f7336ff05be76eb1bd33852340e343e4f7155aa27cb2a61170e546aa02b0c0ae68617830ff721e2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">呀嘞呀嘞，要输入密码的哦</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>摸鱼</category>
      
      <category>learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS</title>
    <link href="/2024/10/23/ICS/"/>
    <url>/2024/10/23/ICS/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-程序的转换及机器级表示"><font color=orange>第三章 程序的转换及机器级表示</font></h1><h2 id="总述"><font color=brown>总述</font></h2><ul><li>计算机指令分为微指令、机器指令和伪（宏）指令，微指令属于硬件范畴；伪指令是若干机器指令组成的序列，属于软件范畴；机器指令介于二者之间。机器指令的汇编语言表示形式为<strong>汇编指令</strong>。机器指令与汇编指令一一对应，<strong>都与具体机器结构有关</strong>，都属于<strong>机器级指令</strong>。<br /></li><li>书中主要阐释C语言和IA-32机器级指令的对应关系，使用寄存器传送语言(RTL)，符号约定如下。</li></ul><h2 id="符号约定"><font color=brown>符号约定</font></h2><h3 id="寄存器语言"><font color=brown>寄存器语言</font></h3><ul><li><strong>R[r]</strong> 表示寄存器r的内容，<strong>M[addr]</strong> 表示存储单元addr的内容，寄存器r采用不带%的形式表示；<br /></li><li><strong>M[PC]</strong> 表示PC所指存储单元的内容，<strong>M[R[r]]</strong> 表示寄存器r的内容所指的存储单元的内容；<br /></li><li>传送方向以<span class="math inline">\(\leftarrow\)</span>表示，传送源在右，传送目的在左；</li><li>书中寄存器名称书写约定：寄存器的名称若出现在单独一行的汇编指令或寄存器传送语言中则用小写，若出现在正文段落或其他部分则大写；<br /></li><li>书中汇编指令及其名称书写约定：具体一条汇编指令或其名称用小写，泛指一类指令的指令名称时用大写。</li></ul><h3 id="汇编格式"><font color=brown>汇编格式</font></h3><p>采用<strong>AT&amp;T</strong> 汇编格式，格式要求如下： <img src="https://www.helloimg.com/i/2024/10/23/6718e823c2ef2.png" alt="AT&amp;T格式" /></p><h2 id="section"><font color=brown></font></h2>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序与搜索算法</title>
    <link href="/2024/10/19/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <url>/2024/10/19/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法">排序算法</h1><h2 id="heapsort">HeapSort</h2><p>用Binary Max-heap来实现排序，首先很容易想到的就是首先从原数组生成一个二叉最大堆，然后调用<span class="math inline">\((n-1)\)</span>次HeapExtractMax()。当然，为了减少空间开支，每次取出的当前最大元素可以放到后面。伪代码如下：<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">HeapSort(data[<span class="hljs-number">1</span>…n]):<br>    heap = BuildMaxHeap(data[<span class="hljs-number">1</span>…n])<br>    <span class="hljs-keyword">for</span> i=n down to <span class="hljs-number">2</span><br>        cur_max = heap.HeapExtractMax()<br>        data[i] = cur_max<br></code></pre></td></tr></table></figure></p><p>对于循环中调用HeapExtractMax()，时间复杂度为<span class="math inline">\(\sum\limits_{i=2}^{n}O(lgi)=O(lg(n!))=O(nlgn)\)</span>.对于前面根据数组建立二叉最大堆，如果使用<span class="math inline">\(n\)</span>次HeapInsert()，我们将再次花费<span class="math inline">\(O(nlgn)\)</span>.<br /><font color=#F08080 size=4 face="黑体">然而，我们有更好的建立二叉最大堆的手段.</font>考虑分治算法，我们将原数组看为一个二叉堆，只是这个二叉堆需要恢复最大堆的性质，那么最底一层的视为单节点的二叉最大堆，此后将索引移至上一层的最右侧节点，对它及它的两个字节使用MaxHeapify()函数（见同目录下“常用数据结构”一文）维护二叉最大堆的性质，以此类推。故BuildMaxHeap()的伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">BuildMaxHeap(data[<span class="hljs-number">1</span>…n]):<br>    heap_size = n<br>    <span class="hljs-keyword">for</span> i=Floor(n/<span class="hljs-number">2</span>) down to <span class="hljs-number">1</span><br>        MaxHeapify(i)<br></code></pre></td></tr></table></figure><p>考虑到高度为<span class="math inline">\(h\)</span>的节点应不超过<span class="math inline">\(\lceil \frac{n}{2^{h+1}}\rceil\)</span>个，每个高度为<span class="math inline">\(h\)</span>的节点使用MaxHeapify()的时间复杂度均为<span class="math inline">\(O(h)\)</span>，因而BuildMaxHeap的时间复杂度为<span class="math inline">\(\sum\limits_{h=0}^{\lfloor lgn\rfloor}(\lceil \frac{n}{2^{h+1}}\rceil O(h))=O(n)\)</span>.</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构与算法分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遗传算法与模拟退火算法</title>
    <link href="/2024/10/19/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E4%B8%8E%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/"/>
    <url>/2024/10/19/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E4%B8%8E%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数模算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用数据结构</title>
    <link href="/2024/10/19/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/10/19/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="heap堆"><font color=orange>Heap(堆)</font></h1><p>堆是用来存放优先队列的数据结构。二叉堆是完全二叉树中的一种，指除去叶节点所在层外各层均填满，且叶节点所在层的节点都尽可能挂靠在左侧父节点上。</p><ul><li>Max-heap(最大堆/大顶堆):除根节点外，各节点的值均小于其父节点的值。<br /></li><li>Min-heap(最小堆/小顶堆):除根节点外，各节点的值均大于其父节点的值。</li></ul><p>常使用数组来存放二叉堆，记节点<span class="math inline">\(u\)</span>的索引为<span class="math inline">\(index_u\)</span>，则其父节点（若有）索引为<span class="math inline">\(\lfloor index_u/2\rfloor\)</span>，其左子节点（若有）索引为<span class="math inline">\(2index_u\)</span>，右子节点（若有）索引为<span class="math inline">\(2index_u+1\)</span>.<br />如此，通过一个节点去找到其父节点和子节点只需<span class="math inline">\(O(1)\)</span>的时间.</p><h2 id="binary-max-heap二叉大顶堆二叉最大堆"><font color=orange>Binary Max-heap（二叉大顶堆/二叉最大堆）</font></h2><h3 id="支持的操作"><font color=brown>支持的操作</font></h3><ul><li>HeapInsert : 向Max-heap中插入一个元素；<br /></li><li>HeapGetMax : 从Max-heap中得到值最大的元素（注意并不将该元素从堆中取出！）；<br /></li><li>HeapExtractMax : 从Max-heap中得到并移除值最大的元素。</li></ul><h3 id="支持操作的实现"><font color=brown>支持操作的实现</font></h3><h4 id="o-heapinsert"><span class="math inline">\(1^o\)</span> HeapInsert</h4><p><font color=#B0C4DE size=4 face="黑体">概述</font> 实现插入的同时要维护最大堆的性质。欲插入新元素，可将新元素接到数组的尾部，在图形上相当于将新元素挂靠在首个子节点个数小于2的节点下。此后一直比较新元素的值和其父节点的值，若新元素的值更大，则交换两节点；否则，算法终止。若无父节点，即新元素已成为新的根节点，算法亦终止。<br /><font color=#B0C4DE size=4 face="黑体">正确性</font> 若发生交换，则原父节点的值必定小于插入元素的值，，进而插入元素的值大于原父节点的左子节点以及以左子节点为祖先的所有节点的值；而原父节点又必然大于以插入元素所在节点为祖先节点的所有子节点的值，故以交换之后插入元素所在节点为祖先节点的所有子节点构成的树必然保持了原性质，而除去这些节点以外的原来所有节点所构成的树没有和插入元素前无变化，故也最大堆性质不变。唯一会破坏性质的地方就是在插入元素现在所在节点及其父节点之间，即两颗子树连接的地方。由归纳法，可推出算法正确性。<br /><font color=#B0C4DE size=4 face="黑体">伪代码</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">HeapInsert(x):<br>    heap_size++<br>    data[heap_size] = x<br>    idx = heap_size<br>    <span class="hljs-keyword">while</span> (idx&gt;<span class="hljs-number">1</span> and data[Floor(idx/<span class="hljs-number">2</span>)]&lt;data[idx])<br>    Swap(data[Floor(idx/<span class="hljs-number">2</span>)], data[idx])<br>    idx = Floor(idx/<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><font color=#B0C4DE size=4 face="黑体">时间复杂度</font> 显然循环数最大为树高，而树高为<span class="math inline">\(O(\lceil lg(n+1)\rceil-1)=O(lgn)\)</span></p><h4 id="o-heapgetmax"><span class="math inline">\(2^o\)</span> HeapGetMax</h4><p>直接将索引为1的元素的值赋予一个新变量即可。时间为<span class="math inline">\(O(1)\)</span>。</p><h4 id="o-heapextractmax"><span class="math inline">\(3^o\)</span> HeapExtractMax</h4><p><font color=#B0C4DE size=4 face="黑体">概述</font> 将根节点移除，将数组中索引最大的元素（记为元素<span class="math inline">\(u\)</span>）填入根节点位置，随后逐层比较<span class="math inline">\(u\)</span>和其所在位置的两个子节点的大小关系，若<span class="math inline">\(u\)</span>比较大的子节点的值小，则交换二者。否则，算法停止。<br /><font color=#B0C4DE size=4 face="黑体">正确性</font> 使用归纳法。对于树高为1（<font color=#F08080 size=4 face="黑体">为了行文方便，这里树高指的是根节点的高度+1，因而只有一个节点的树的树高为1，而该节点的高度为0.</font>）的树，即只有一个节点，则显然算法正确；假定对于高度为<span class="math inline">\(k\)</span>的树该算法正确，则对于高度为<span class="math inline">\(k+1\)</span>的树，若索引最大的节点<span class="math inline">\(u\)</span>的值大于深度为1的两个子节点中值较大的，则由于以两子节点为根节点的子树内部没有发生变化，故新树整体仍然维持了最大堆性质；若不然，则<span class="math inline">\(u\)</span>与值较大的子节点交换，值较大的子节点大于另一子节点，而以另一子节点为根节点的子树内部未发生变化，故最大堆性质保留；而<span class="math inline">\(u\)</span>在交换后，成为了一个高度不大于<span class="math inline">\(k\)</span>的树的根节点，而以其两个子节点为根节点的子树内部均未发生变化，由归纳假设知<span class="math inline">\(u\)</span>最后会排到合适的位置。综上，算法正确。<br /><font color=#B0C4DE size=4 face="黑体">伪代码</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C">HeapExtractMax():<br>    max_item = data[<span class="hljs-number">1</span>]<br>    data[<span class="hljs-number">1</span>] = data[heap_size--]<br>    MaxHeapify(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> max_item<br><br>MaxHeapify(idx):<br>    idx_l = <span class="hljs-number">2</span>*i, idx_r = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span><br>    idx_max = (idx_l&lt;=heap_size &amp;&amp; data[idx_l]&gt;data[idx])?idx_l:idx<br>    idx_max = (idx_r&lt;=heap_size &amp;&amp; data[idx_r]&gt;data[idx_max])?idx_r:idx_max<br>    <span class="hljs-keyword">if</span> (idx_max != idx)<br>        Swap(data[idx_max], data[idx])<br>        MaxHeapify(idx_max)<br><br></code></pre></td></tr></table></figure><p><font color=#B0C4DE size=4 face="黑体">时间复杂度</font> 显然递归调用数最大为树高，故时间复杂度亦为<span class="math inline">\(O(lgn)\)</span>.</p><h2 id="priority-queue优先队列"><font color=orange>Priority Queue（优先队列）</font></h2><h3 id="支持的操作-1"><font color=brown>支持的操作</font></h3><ul><li>Add(item) : HeapInsert(item)<br /></li><li>Remove() : HeapExtractMax()<br /></li><li>GetMax() : HeapGetMax()<br /></li><li>UpdatePriority(item,val)</li></ul><h3 id="支持操作的实现-1"><font color=brown>支持操作的实现</font></h3><h4 id="oadditem"><span class="math inline">\(1^o\)</span>Add(item)</h4><p>使用HeapInsert(item)即可，时间复杂度即为HeapInsert(item)的时间复杂度，为<span class="math inline">\(O(lgn)\)</span>.</p><h4 id="oremove"><span class="math inline">\(2^o\)</span>Remove</h4><p>使用HeapExtract()即可，时间复杂度与之相同，为<span class="math inline">\(O(lgn)\)</span>.</p><h4 id="ogetmax"><span class="math inline">\(3^o\)</span>GetMax</h4><h4 id="oupdatepriorityitemval"><span class="math inline">\(4^o\)</span>UpdatePriority(item,val)</h4><h2 id="heapsort"><font color=orange>HeapSort</font></h2><p>请见同目录下“排序与搜索算法”一文。</p><h1 id="searching-tree"><font color=orange>Searching Tree</font></h1><h1 id="hashing"><font color=orange>Hashing</font></h1>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构与算法分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>铺垫</title>
    <link href="/2024/10/19/%E9%93%BA%E5%9E%AB/"/>
    <url>/2024/10/19/%E9%93%BA%E5%9E%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="函数的增长">函数的增长</h1><h2 id="渐进记号">渐进记号</h2><h3 id="theta记号"><span class="math inline">\(\Theta\)</span>记号</h3><p><span class="math display">\[\Theta(g(n))=\{f(n)|\exists c_1,c_2,n_0&gt;0~~s.t.~~\forall n\geq n_0,0\leq c_1g(n)\leq f(n)\leq c_2g(n)\}\]</span><br />注意，以上定义要求对<span class="math inline">\(\forall f(n)\in \Theta(g(n))\)</span>，<span class="math inline">\(f(n)\)</span>应当是渐进非负的，即<span class="math inline">\(n\)</span>足够大时，<span class="math inline">\(f(n)\)</span>是非负的。对于满足以上条件的<span class="math inline">\(f(n)\)</span>,我们称<span class="math inline">\(g(n)\)</span>是<span class="math inline">\(f(n)\)</span>的一个<strong>渐进紧确界</strong>。</p><h3 id="o记号渐进上界"><span class="math inline">\(O\)</span>记号（渐进上界）</h3><p><span class="math display">\[O(g(n))=\{f(n)|\exists c,n_0&gt;0~~s.t.~~\forall n\geq n_0,0\leq f(n)\leq cg(n)\}\]</span><br /><span class="math inline">\(O\)</span>记号用以描述渐近上界，对于一个算法的时间复杂度而言，当我们说一个算法的时间复杂度为<span class="math inline">\(O(g(n))\)</span>时，我们说的是存在一个<span class="math inline">\(O(g(n))\)</span>的函数<span class="math inline">\(f(n)\)</span>，不管选定怎样的规模为<span class="math inline">\(n\)</span>的输入，<span class="math inline">\(f(n)\)</span>都是运行时间的一个上界。</p><h3 id="omega记号渐进下界"><span class="math inline">\(\Omega\)</span>记号（渐进下界）</h3><p><span class="math display">\[\Omega(g(n))=\{f(n)|\exists c,n_0~~s.t.\forall n\geq n_0,0\geq cg(n)\geq f(n)\}  \]</span> <span class="math inline">\(\Omega\)</span>记号用以描述渐近下界，当我们说一个算法的渐近下界为<span class="math inline">\(\Omega(g(n))\)</span>时，指的是对任意输入，运行时间不会少于一个<span class="math inline">\(\Omega(g(n))\)</span>的<span class="math inline">\(f(n)\)</span>。<br />由此不难得到一个很显然的推论：</p><blockquote><p><strong>T.H.</strong> <span class="math display">\[\forall f(n),g(n),~~f(n)=\Theta(g(n))\iff f(n)=O(g(n))~and~f(n)=\Omega(g(n))  \]</span></p><hr /></blockquote><p><font color=#9370D8 size=3 face="宋体">似乎比起<span class="math inline">\(f(n)=O(g(n))\)</span>，使用<span class="math inline">\(f(n)\in O(g(n))\)</span>更合适？但是书上确实是用的等于，应该也是为了方便平时推导时间复杂度罢（确信）</font><br /><br> <font color=#F08080 size=3 face="黑体">补：在后面“等式和不等式中的渐近符号”中确实提到了使用等号代替集合论属于符号的好处。</font></p><h3 id="o记号非渐近紧确上界"><span class="math inline">\(o\)</span>记号（非渐近紧确上界）</h3><p><span class="math display">\[o(g(n))=\{f(n)|\forall c&gt;0,\exists n_0&gt;0~~s.t.~~\forall n\geq n_0,0\leq f(n)&lt;cg(n)\}\]</span><br />注意这里的常数<span class="math inline">\(c\)</span>是任取的，因而尽管<span class="math inline">\(2n^2=O(n^2)\)</span>，但是<span class="math inline">\(2n^2\neq o(n^2)\)</span>.有些书中将<span class="math inline">\(o\)</span>记号定义为<span class="math inline">\(\lim\limits_{n\rightarrow+\infty}\frac{f(n)}{g(n)}=0\)</span>.</p><h3 id="omega记号非渐近紧确下界"><span class="math inline">\(\omega\)</span>记号（非渐近紧确下界）</h3><p><span class="math display">\[\omega(g(n))=\{f(n)|\forall c&gt;0,\exists n_0&gt;0,~~s.t.~~\forall n\geq n_0,0\leq cg(n)&lt;f(n)\}  \]</span><br />相应地也可以用极限表示为<span class="math inline">\(\lim\limits_{n\rightarrow+\infty}\frac{f(n)}{g(n)}=\infty\)</span></p><h2 id="主定理">主定理</h2><blockquote><p><strong>T.H.</strong><br />若函数<span class="math inline">\(T(n)\)</span>满足以下递推关系：<br /><span class="math display">\[T(n)=\left\{\begin{array}{ll}\Theta(1)&amp; \text{if }~n=1\\aT(\frac{n}{b})+f(n)&amp;\text{if }~n=b^i\end{array}\right. \]</span> 若<span class="math inline">\(a\geq 1,b&gt;1\)</span>，且<span class="math inline">\(f(n)\)</span>为定义在<span class="math inline">\(b\)</span>的幂上的非负函数，则有<br /><span class="math display">\[T(n)=\Theta(n^{log_ba})+\sum\limits_{j=0}^{log_bn-1}a^jf(\frac{n}{b^j})  ~~~~~~~~\mathbb{(1)}\]</span> 进一步地，有如下渐近界：<br />1.若对某个常数<span class="math inline">\(\epsilon&gt;0\)</span>有<span class="math inline">\(f(n)=O(n^{log_ba-\epsilon})\)</span>，则<span class="math inline">\(T(n)=\Theta(n^{log_ba})\)</span>;<br />2.若<span class="math inline">\(f(n)=\Theta(n^{log_ba})\)</span>，则<span class="math inline">\(T(n)=\Theta(n^{log_ba}lgn)\)</span>;<br />3.若对某个常数<span class="math inline">\(\epsilon&gt;0\)</span>，有<span class="math inline">\(f(n)=\Omega(n^{log_ba+\epsilon})\)</span>，且对某个常数<span class="math inline">\(c&lt;1\)</span>和所有足够大的<span class="math inline">\(n\)</span>有<span class="math inline">\(af(\frac{n}{b})\leq cf(n)\)</span>，则<span class="math inline">\(T(n)=\Theta(f(n))\)</span>。</p><hr /></blockquote><p><font color=#B0C4DE size=4 face="黑体">proof:<br />(1)式用递推树或者直接思考都是易得的。后面三种情况其实是在讨论<span class="math inline">\(\sum\limits_{j=0}^{log_bn-1}a^jf(\frac{n}{b^i})\)</span>的渐近界。<br />对于第一种情况，有<br /><span class="math display">\[\begin{align*}\sum\limits_{j=0}^{log_bn-1}a^jf(\frac{n}{b^j})&amp;=O(\sum\limits_{j=0}^{log_bn-1}a^j(\frac{n}{b^j})^{log_ba-\epsilon})=O(n^{log_ba-\epsilon}\sum\limits_{j=0}^{log_bn-1}(\frac{ab^\epsilon}{b^{log_ba}})^j)\\&amp;=O(n^{log_ba-\epsilon}\frac{n^\epsilon-1}{b^\epsilon-1})=O(n^{log_ba})\end{align*}\]</span> 因而<span class="math inline">\(T(n)=\Theta(n^{log_ba})+O(n^{log_ba})=\Theta(n^{log_ba})\)</span>.<br /><br> 对于第二种情况，只需要在前一种情况的推导过程中使用等比数列前的最后一步把<span class="math inline">\(\epsilon=0\)</span>代入并在其基础上继续推导即可：<br /><span class="math display">\[\begin{align*}\sum\limits_{j=0}^{log_bn-1}a^jf(\frac{n}{b^j})&amp;=\Theta(\sum\limits_{j=0}^{log_bn-1}a^j(\frac{n}{b^j})^{log_ba})\\&amp;=\Theta(n^{log_ba}\sum\limits_{j=0}^{log_bn-1}(\frac{a}{b^{log_ba}})^j)\\&amp;=\Theta(n^{log_ba}log_bn)\end{align*}\]</span> 因而<span class="math inline">\(T(n)=\Theta(n^{log_ba})+\Theta(n^{log_ba}log_bn)=\Theta(n^{log_ba}log_bn)\)</span>.<br /><br></p><p>对于第三种情况，由于<span class="math inline">\(af(\frac{n}{b})\leq cf(n)\)</span>，故<span class="math inline">\(f(\frac{n}{b})\leq (\frac{c}{a})f(n)\)</span>，进而有<span class="math inline">\(f(\frac{n}{b^j})\leq (\frac{c}{a})^jf(n)\)</span>，亦即<span class="math inline">\(a^jf(\frac{n}{b^j})\leq c^jf(n)\)</span>.因此，我们有:<br /><span class="math display">\[\begin{align*}\sum\limits_{j=0}^{log_bn-1}a^jf(\frac{n}{b^j})\leq O(1)+\sum\limits_{j=0}^{log_bn-1}c^jf(n)\leq O(1)+f(n)\sum\limits_{j=0}^{\infty}c^j\leq \frac{f(n)}{1-c}+O(1)=O(f(n))  \end{align*}\]</span> 同时由于<span class="math inline">\(\sum\limits_{j=0}^{log_bn-1}a^jf(\frac{n}{b^j})\geq a^jf(\frac{n}{b^j})|_{j=0}=f(n)\)</span>,故<span class="math inline">\(g(n)=\Omega(f(n))\)</span>，所以<span class="math inline">\(g(n)=\Theta f(n)\)</span>.<br />因而<span class="math inline">\(T(n)=\Theta(n^{log_ba})+\Theta(f(n))=\Theta(f(n))\)</span>，注意此情况的前提条件中给出了<span class="math inline">\(f(n)=\Omega(n^{log_ba+\epsilon})\)</span> </font></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构与算法分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>连续型随机变量</title>
    <link href="/2024/10/18/%E8%BF%9E%E7%BB%AD%E6%80%A7%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/"/>
    <url>/2024/10/18/%E8%BF%9E%E7%BB%AD%E6%80%A7%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="连续型随机变量">连续型随机变量</h1><h2 id="期望">期望</h2><h3 id="非负随机变量x">非负随机变量X</h3><p><font color=#9370D8 size=4 face="黑体">T.H.对于非负随机变量X，有<span class="math display">\[  E[X]=\int_0^{+\infty}P(X&gt;t)dt\\\]</span><br /></font></p><p><font color=#B0C4DE size=4 face="黑体">proof: <span class="math display">\[  \begin{align*}E[x] &amp; =\int_0^{+\infty}xf(x)dx\\&amp; =\int_0^{+\infty}(\int_0^{x}I[t\leq x]dt+\int_{x}^{+\infty}I[t\leq x]dt)f(x)dx\\&amp; =\int_0^{+\infty}\int_0^{+\infty}I[t\leq x]f(x)dtdx\\&amp; =\int_0^{+\infty}dt\int_0^{+\infty}I[t\leq x]f(x)dx\\&amp; =\int_0^{+\infty}dt\int_t^{+\infty}f(x)dx \\&amp; =\int_0^{+\infty}p(X\geq t)dt \end{align*}\]</span><br /></font></p><blockquote><p><strong>复习一下求导</strong><br /><span class="math inline">\(F(t)=P(X\leq t)\)</span>为分布函数，<span class="math inline">\(f(x)\)</span>为概率密度函数。<br />对函数 <span class="math display">\[  \begin{align*}h(t)&amp;=\int_0^{t}(t-x)cf(x)dx+\int_t^{+\infty}(x-t)Cf(x)dx\\\end{align*}\]</span><br />第一项求导为<span class="math inline">\(cF(t)+ctf(t)-ctf(t)=cF(t)\)</span><br />第二项求导为：<br /><span class="math display">\[\begin{align*}原式&amp;=(\int_t^{+\infty}(x-t)Cf(x)dx)^{&#39;}\\&amp;=C(\int_t^{+\infty}xf(x)dx)^{&#39;}-C(\int_t^{+\infty}tf(x)dx)^{&#39;}\\&amp;=C(-tf(t))-Ct(\int_t^{+\infty}f(x)dx)^{&#39;}-C\int_t^{+\infty}f(x)dx\\&amp;=-Ctf(t)-Ct(1-F(t))^{&#39;}-C(1-F(t))\\&amp;=-Ctf(t)+Ctf(t)-C(1-F(t))\\&amp;=CF(t)-C\end{align*}\]</span> 故h(t)求导为<span class="math inline">\(h^{&#39;}(t)=(c+C)F(t)-C\)</span></p><hr /></blockquote><h2 id="常用连续分布">常用连续分布</h2><p>判断一个分布是否是连续分布，需要检查其规范性和非负性。</p><h3 id="均匀分布">均匀分布</h3><h3 id="指数分布">指数分布</h3><p>给定常数<span class="math inline">\(\lambda&gt;0\)</span>，若随机变量X的概率密度函数 <span class="math display">\[f(x) = \left\{\begin{array}{ll}\lambda e^{-\lambda x} &amp; \text{if } x \geq 0 \\0 &amp; \text{if } 其他\end{array}\right.\]</span><br />则称X服从参数为<span class="math inline">\(\lambda\)</span>的指数分布，记为<span class="math inline">\(X\sim e(\lambda)\)</span>.<br />进而易得分布函数<br /><span class="math display">\[F(x) = \left\{\begin{array}{ll}\int_0^x\lambda e^{-\lambda t}dt=1-e^{-\lambda x}&amp; \text{if } x &gt; 0 \\0 &amp; \text{if } 其他\end{array}\right.\]</span></p><p><br><br /><br><br /><font color=#F08080 size=6 face="黑体">指数分布是唯一具有无记忆性的连续型随机变量</font></p><p><font color=#B0C4DE size=4 face="黑体">proof: <span class="math display">\[\begin{align*}&amp;F(x)=1-e^{-\lambda x}=P(X\leq x)\\&amp;P(X&gt;x)=e^{-\lambda x}\\&amp;P(X.s+t|x&gt;t)=\frac{P(X&gt;s+t)}{P(x&gt;t)}=\frac{e^{-\lambda (s+t)}}{e^{-\lambda t}}=e^{-\lambda s}=P(X&gt;s).\\\end{align*}\]</span> </font></p><h3 id="正态分布">正态分布</h3><p>给定<span class="math inline">\(u\in(-\infty,+\infty)\)</span>和<span class="math inline">\(\sigma&gt;0\)</span>，若随机变量<span class="math inline">\(X\)</span>的概率密度为<br /><span class="math display">\[  f(x)=\frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma ^2}},x\in(-\infty,+\infty)\]</span><br />则称<span class="math inline">\(X\)</span>服从参数为<span class="math inline">\(\mu,\sigma^2\)</span>的正态分布，记为<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>.<br />特别地，若<span class="math inline">\(\mu=0\)</span>和<span class="math inline">\(\sigma=1\)</span>，则称<span class="math inline">\(N(0,1)\)</span>为标准正态分布，此时密度函数为<span class="math inline">\(f(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}\)</span></p>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RTFSC</title>
    <link href="/2024/10/15/RTFSC/"/>
    <url>/2024/10/15/RTFSC/</url>
    
    <content type="html"><![CDATA[<h1 id="pa2">PA2</h1><h2 id="mtrace">mtrace</h2><p>  在~/ics2024/am-kernels/tests/cpu-tests/build中运行指令riscv64-linux-gnu-readelf -a add-riscv32-nemu.elf，即可查看其对应的符号表。   在.c中找到parse_args函数，在里面添加关于elf读入的设置，</p><h2 id="时钟">时钟</h2><p>  在ics2024/abstract-machine/am/src/riscv/riscv.h中定义了inl用以取出32位无符号整数，联系gitbook中提到时钟是 <strong>“计时器初始化时会分别注册0x48处长度为8个字节的端口, 以及0xa0000048处长度为8字节的MMIO空间, 它们都会映射到两个32位的RTC寄存器. CPU可以访问这两个寄存器来获得用64位表示的当前时间.”</strong>，因而这个就是用以取32位寄存器的。<br />  而在ics2024/abstract-machine /am /src /platform /nemu /include/nemu.h中定义的RTC_ADDR就是实时时钟RTC的地址了。</p><h2 id="跑分测试">跑分测试</h2><p>  出了点小插曲后吓得赶紧留了个快照，不过快照留了有点匆忙，忘了把printf()实现中的putch('a')注释掉了，下次用的时候得注意了......(不过希望我永远也不需要再回退回来罢quq)<br />  在menu文件夹下运行指令 <figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs make">make menuconfig<br>```  <br>&gt; **总是会遗忘**  <br>&gt;   <br>&gt; - 如果想要在NEMU中配置一些可供选择开启与否的宏，可以在ics2024/nemu/Kconfig中添加相关定义。注意，在Kconfig中定义的名字，实际生成的宏是会加<span class="hljs-string">&quot;CONFIG_&quot;</span>前缀的。比如我在Kconfig中添加MTRACE的定义，那么实际定义出来的宏是CONFIG_MTRACE。  <br>&gt;   <br>&gt; ---    <br><br><br><span class="hljs-comment"># 一些关于抽象层的理解  </span><br><span class="hljs-section">背景是首先看到了gitbook上的https://nju-projectn.github.io/ics-pa-gitbook/ics2024/2.3.html#%E5%B0%86%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83%E5%B0%81%E8%A3%85%E6%88%90%E5%BA%93%E5%87%BD%E6%95%B0  讨论的关于n+m和n*m的问题，又看到了gitbook上的https://nju-projectn.github.io/ics-pa-gitbook/ics2024/2.3.html#%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E4%B8%AA%E6%8A%BD%E8%B1%A1%E5%B1%82  ，所以决定整理一下。  </span><br>在实现klib的printf时，输出单个字符用的是putch()。进行RTFSC，可以看到就如gitbook所说，不同的平台(platform)实现putch不完全一样。在native上，直接用的putchar()函数；而我们亲爱的NEMU（笑）用的是outb()函数，而outb()函数在不同的指令集(ISA)上有不同的定义，如在riscv.h,mips.h,loongarch32.h中都定义为  <br>```C<br>static inline void outb(uintptr_t addr, uint8_t  data) &#123; *(volatile uint8_t  *)addr = data; &#125;  <br></code></pre></td></tr></table></figure></p><p>而在x86.h中定义为<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">outb</span><span class="hljs-params">(<span class="hljs-type">int</span> port, <span class="hljs-type">uint8_t</span> data)</span> &#123;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;outb %%al, %%dx&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span>(data), <span class="hljs-string">&quot;d&quot;</span>((<span class="hljs-type">uint16_t</span>)port))</span>;<br>&#125;  <br></code></pre></td></tr></table></figure></p><p>而outb仅仅是用以把字符串写入串口的，最终把字符串打印到终端的工作是由NEMU中的serial_io_handler()承担。它的定义如下：</p><div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="dt">static</span> <span class="dt">void</span> serial_io_handler(<span class="dt">uint32_t</span> offset, <span class="dt">int</span> len, <span class="dt">bool</span> is_write) &#123;</a><a class="sourceLine" id="cb1-2" data-line-number="2">  assert(len == <span class="dv">1</span>);</a><a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="cf">switch</span> (offset) &#123;</a><a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="co">/* We bind the serial port with the host stderr in NEMU. */</span></a><a class="sourceLine" id="cb1-5" data-line-number="5">    <span class="cf">case</span> CH_OFFSET:</a><a class="sourceLine" id="cb1-6" data-line-number="6">      <span class="cf">if</span> (is_write) serial_putc(serial_base[<span class="dv">0</span>]);</a><a class="sourceLine" id="cb1-7" data-line-number="7">      <span class="cf">else</span> panic(<span class="st">&quot;do not support read&quot;</span>);</a><a class="sourceLine" id="cb1-8" data-line-number="8">      <span class="cf">break</span>;</a><a class="sourceLine" id="cb1-9" data-line-number="9">    <span class="cf">default</span>: panic(<span class="st">&quot;do not support offset = %d&quot;</span>, offset);</a><a class="sourceLine" id="cb1-10" data-line-number="10">  &#125;</a><a class="sourceLine" id="cb1-11" data-line-number="11">&#125;</a></code></pre></div><p>由此，库函数中但凡需要打印字符的，均使用每次打印单个字符的putch()，无论平台；不同的平台（也即模拟器），均实现自己的putch()函数，并在和各个指令集接洽的处理手段上解决实现putch()所依赖的行为在具体指令中的处理(NEMU中实现putch()依赖的正是outb()函数。)</p><h1 id="可能的问题"><font color=brown>可能的问题</font></h1><ul><li>nemu32.c 实现的J型立即数，使用BITS与SEXT<br /></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>PA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随机事件与概率，条件概率与独立性，离散型随机变量</title>
    <link href="/2024/10/13/%E5%8F%A4%E5%85%B8%E6%A6%82%E5%9E%8B%E4%B8%8E%E7%A6%BB%E6%95%A3%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/"/>
    <url>/2024/10/13/%E5%8F%A4%E5%85%B8%E6%A6%82%E5%9E%8B%E4%B8%8E%E7%A6%BB%E6%95%A3%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="随机事件与概率">随机事件与概率</h1><h2 id="试验与事件">试验与事件</h2><p>  出现结果不唯一，事先不确定结果的，称为<font color=#F08080 size=4 face="黑体">随机现象</font>；为了研究随机现象的规律<font color=#F08080>（结果的分布）</font>而进行的试验称为<font color=#F08080 size=4 face="黑体">随机试验</font><font color=#B0C4DE size=4 face="黑体">（记为<span class="math inline">\(E\)</span>或<span class="math inline">\(E_i\)</span>）</font>，随机试验具有以下三条性质：</p><ul><li>可重复<br /></li><li>多结果<br /></li><li>不确定</li></ul><p>  随机试验<span class="math inline">\(E\)</span>的每一种可能的结果称为一个<font color=#F08080 size=4 face="黑体">样本点</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(\omega_i~~\)</span></font>. <span class="math inline">\(E\)</span>的所有可能的结果作为元素构成的集合称为<font color=#F08080 size=4 face="黑体">试验<span class="math inline">\(E\)</span>的样本空间</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(\Omega\)</span></font>.样本空间有多种，样本点有限则为<font color=#F08080 size=4>有限样本空间</font>，样本点无限但可列即为<font color=#F08080 size=4 face="黑体">可列样本空间</font>，样本的无线且不可列即为<font color=#F08080 size=4 face="黑体">不可列样本空间</font>。有限样本空间和无限样本空间统称为<font color=#F08080 size=4 face="黑体">离散样本空间</font>。<br />  包含了一些具有相同特性的样本点的集合称为<font color=#F08080 size=4 face="黑体">事件</font>，事件是样本空间的子集。事件也有多种，只包含一个样本点的事件称<font color=#F08080 size=4 face="黑体">基本事件</font>，样本空间<span class="math inline">\(\Omega\)</span>本身称<font color=#F08080 size=4 face="黑体">必然事件</font>，空集<span class="math inline">\(\varnothing\)</span>称<font color=#F08080 size=4 face="黑体">不可能事件</font>。</p><h2 id="事件的关系与运算">事件的关系与运算</h2><p><font color=#9370D8 size=4 face="黑体">1&gt;包含关系</font><br />  对事件A,B，若A发生则必然B发生，则<span class="math inline">\(A\subset B\)</span>.<br /><font color=#9370D8 size=4 face="黑体">2&gt;等于关系</font><br />  若<span class="math inline">\(A\subset B\)</span>且<span class="math inline">\(B\subset A\)</span>,则称<font color=#F08080 size=4 face="黑体">事件A与事件B相等</font>,记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(A=B\)</span></font>。<br /><font color=#9370D8 size=4 face="黑体">3&gt;事件的并/和</font><br />  事件F发生时，若事件<span class="math inline">\(A_1,...,A_n\)</span>中至少有一个发生，则称<font color=#F08080 size=4 face="黑体">事件<span class="math inline">\(F\)</span>为事件<span class="math inline">\(A_i,...,A_n\)</span>的并/和</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(F=\bigcup \limits_{i=1}^{n}A_i=A_1\cup A_2 \cup ... \cup A_n=\{\omega|\exists i\in[n] \hspace{0.2cm} s.t.\hspace{0.2cm}\omega \in A_i\}\)</span></font>.<br /><font color=#9370D8 size=4 face="黑体">4&gt;事件的交/积</font><br />  事件F发生时，若事件<span class="math inline">\(A_1,...,A_n\)</span>全部都发生，则称<font color=#F08080 size=4 face="黑体">事件<span class="math inline">\(F\)</span>为事件<span class="math inline">\(A_i,...,A_n\)</span>的交/积</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(F=\bigcap \limits_{i=1}^{n}A_i=A_1\cap A_2 \cap ... \cap A_n=\{\omega|\forall i\in[n] \hspace{0.2cm} s.t.\hspace{0.2cm}\omega \in A_i\}\)</span></font>.<br /><font color=#9370D8 size=4 face="黑体">5&gt;对立/逆事件</font><br />  所有不属于事件A的基本事件所构成的事件称为<font color=#F08080 size=4 face="黑体">事件A的对立事件（逆事件）</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(\bar{A}=\Omega-A\)</span></font>.<br /><font color=#9370D8 size=4 face="黑体">6&gt;事件的差</font><br />  事件F发生时，若事件<span class="math inline">\(A\)</span>发生且事件<span class="math inline">\(B\)</span>不发生，则称<font color=#F08080 size=4 face="黑体">事件<span class="math inline">\(F\)</span>为事件<span class="math inline">\(A与B\)</span>的差</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(F=A-B=A-AB=A\bar{B}\)</span></font><br /><font color=#9370D8 size=4 face="黑体">7&gt;互不相容/互斥事件</font><br />  若事件<span class="math inline">\(A\)</span>和事件<span class="math inline">\(B\)</span>不能同时发生，则称<font color=#F08080 size=4 face="黑体">事件<span class="math inline">\(A\)</span>与事件<span class="math inline">\(B\)</span>互不相容（互斥）</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(A\cap B=\varnothing\)</span></font>.</p><blockquote><p><strong>会犯错吗？</strong></p><ul><li>如果只有<span class="math inline">\(A-B=A-C\)</span>,那么事件B,C未必满足<span class="math inline">\(B=C\)</span>。</li></ul><hr /></blockquote><blockquote><p><strong><font color=orange size=4>techniques</font></strong></p><ul><li><p>证明两个事件的运算是相等的，我们可以使用瞪眼法，也可以将二者都化为某一特定范式，如BNF或者DNF。</p></li><li><p>e.g.证明<span class="math inline">\((A-B)\cup (B-C)=(A\cup B)-BC\)</span>.<br /><font color=#00ffff size=3 face="黑体">遇到<span class="math inline">\(A-B\)</span>先展开为<span class="math inline">\(A\cap \bar{B}\)</span>，左右两式都化为析取范式，则有:<br />左式=<span class="math inline">\((A\cap \bar{B})\cup(B\cap \bar{C})\)</span><br />右式=<span class="math inline">\((A\cap \bar{B})\cup(B\cap \bar{C})\cup(A\cap\bar{C})\)</span><br />此时右式确实满足析取范式，只是多出来一项冗余项，需要借助语义来证明它可以被前两项的并集包含，进而证明可以去掉冗余项。则：<br /><span class="math inline">\(A\cap \bar{C}=(A\cap\bar{C})\cap(B\cup\bar{B})=(A\cap\bar{C}\cap B)\cup(A\cap \bar{C}\cap\bar{B})\)</span><br />又注意到<span class="math inline">\((A\cap\bar{C}\cap B)\subset(\bar{C}\cap B),(A\cap \bar{C}\cap\bar{B})\subset(A\cap\bar{B})\)</span>,故右式=<span class="math inline">\((A\cap \bar{B})\cup(B\cap \bar{C})\)</span>=左式。 </font></p></li></ul><hr /></blockquote><h2 id="频率与概率公理化">频率与概率公理化</h2><p>  事件<span class="math inline">\(A\)</span>在相同条件下重复进行的<span class="math inline">\(n\)</span>次试验中发生了<span class="math inline">\(n_A\)</span>次，则称<span class="math inline">\(f_n(A)=\frac{n_A}{n}\)</span>为<font color=#F08080 size=4 face="黑体">事件A在n次试验中发生的概率</font>，并称<span class="math inline">\(n_A\)</span>为<font color=#F08080 size=4 face="黑体">事件A发生的频数</font>。<br />  概率的统计定义：<font color=#F08080 size=4 face="黑体">随机事件<span class="math inline">\(A\)</span>在大量重复试验中发生的频率总是稳定在一个常数<span class="math inline">\(p\)</span>附近摆动，且随着试验次数增加而摆幅渐小，则称<span class="math inline">\(p\)</span>为事件<span class="math inline">\(A\)</span>发生的概率</font>，记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(P(A)=p\)</span></font><br />  概率公理化定义：<font color=#F08080 size=4 face="黑体">随机试验<span class="math inline">\(E\)</span>所对应的样本空间<span class="math inline">\(\Omega\)</span>中每一个随机事件<span class="math inline">\(A\)</span>，均赋予一实数<span class="math inline">\(P(A)\)</span>，且满足以下条件：<br /><span class="math inline">\(1^o\)</span> 非负性： 对任意事件<span class="math inline">\(A\)</span>有<span class="math inline">\(P(A)\geq0\)</span>；<br /><span class="math inline">\(2^o\)</span> 规范性： 对样本空间<span class="math inline">\(\Omega\)</span>有<span class="math inline">\(P(\Omega)=1\)</span>；<br /><span class="math inline">\(3^o\)</span> 可列可加性： 若<span class="math inline">\(A_1,A_2,...,A_n,...\)</span>是可列无穷个互不相容的事件，即<span class="math inline">\(A_iA_j=\varnothing(i\neq j)\)</span>，有<span class="math inline">\(P(A_1\cup A_2\cup ...\cup A_n\cup...)=P(A_1)+P(A_2)+...+P(A_n)+...\)</span>.<br />   则称<span class="math inline">\(P(A)\)</span>为随机事件<span class="math inline">\(A\)</span>的概率. </font></p><p>  公理化定义中只规定了可列可加性，因而有限可加性是需要我们自己根据公里导出的。这里只证最重要的两条，其他性质主要就是由这两条导出的了。<br /><strong><span class="math inline">\(1^o\)</span> 对不可能事件<span class="math inline">\(\varnothing\)</span>有<span class="math inline">\(P(\varnothing)=0\)</span>.</strong><br />  proof:取<span class="math inline">\(A_i=\varnothing(i=1,2,...)\)</span>,则<span class="math inline">\(A_i\cap A_j=\varnothing(i\neq j)\)</span>.据公理3可得<span class="math inline">\(P(\varnothing)=P(\bigcup \limits_{i=1}^{\infty}A_i)=\sum \limits_{i=1}^{\infty}P(A_i)=\sum \limits_{i=1}^{\infty}P(\varnothing)\)</span>，又由第一条公理非负性，可知<span class="math inline">\(P(\varnothing)=0\)</span>.<br /><strong><span class="math inline">\(2^o\)</span> 有限可加性：若<span class="math inline">\(A_1,A_2,...,A_n\)</span>是两两不相容事件，则<span class="math inline">\(P(\bigcup \limits_{i=1}^{n}A_i)=\sum \limits_{i=1}^{n}P(A_i)\)</span>.</strong><br />  proof:取<span class="math inline">\(A_i=\varnothing(i&gt;n)\)</span>,则<span class="math inline">\(\bigcup\limits_{i=1}^{n}A_i=\bigcup\limits_{i=1}^{\infty}A_i\)</span>.又由扩展后<span class="math inline">\(A_1,A_2,...,A_n,A_{n+1},...\)</span>两两不相容，据公理3可得<span class="math inline">\(P(\bigcup \limits_{i=1}^{n}A_i)=P(\bigcup \limits_{i=1}^{\infty}A_i)=\sum \limits_{i=1}^{n}P(A_i)+\sum \limits_{i=n+1}^{\infty}P(\varnothing)=\sum \limits_{i=1}^{n}P(A_i)\)</span>.</p><p>  <strong>容斥原理推广：</strong><br /><span class="math display">\[P(\bigcup\limits_{i=1}^{n}A_i)=\sum\limits_{r=1}^{n}(-1)^{r+1}\sum\limits_{i_1&lt;...&lt;i_r}P(A_{i_1}\cdots A_{i_r})\]</span></p><p>  <strong>Union Bound:</strong><br /><span class="math display">\[P(A_1\cup A_2\cup\cdots\cup A_n)\leq P(A_1)+P(A_2)+\cdots +P(A_n)\]</span></p><p>  以上两条性质都可以使用归纳法证明。</p><h2 id="古典概型">古典概型</h2><p>  对于满足<span class="math inline">\(1^o\)</span>试验结果仅有有限种可能<span class="math inline">\(2^o\)</span>每种结果等可能地发生 的试验<span class="math inline">\(E\)</span>，称该类试验为<font color=#F08080 size=4 face="黑体">古典概型(等可能概型)</font>。<br />  对于古典概型，有事件<span class="math inline">\(A\)</span>发生的概率为<span class="math inline">\(P(A)=\frac{|A|}{|\Omega|}\)</span>，其中<span class="math inline">\(|A|\)</span>表示事件<span class="math inline">\(A\)</span>包含的<span class="math inline">\(\Omega\)</span>中的基本事件的个数。<br />  一些符号约定： <span class="math display">\[(n)_r=A_n^r=\frac{n!}{(n-r)!}  \]</span> <span class="math display">\[(_r^n)=C_n^r=\frac{n!}{r!(n-r)!}\]</span></p><h2 id="几何概型">几何概型</h2><p>  对于满足<span class="math inline">\(1^o\)</span>样本空间无限且可测<span class="math inline">\(2^o\)</span>基本事件等可能性（每个事件发生概率仅与其几何测度相关而与位置无关） 的试验<span class="math inline">\(E\)</span>，称该类试验为<font color=#F08080 size=4 face="黑体">几何概型</font>。<br />  对于几何概型，有事件<span class="math inline">\(A\)</span>发生的概率为<span class="math inline">\(P(A)=\frac{A的测度}{\Omega的测度}=\frac{\mu(A)}{\mu(\Omega)}\)</span>。</p><h1 id="条件概率与独立性">条件概率与独立性</h1><p>  将事件<span class="math inline">\(A\)</span>发生的条件下事件<span class="math inline">\(B\)</span>发生的概率记为<font color=#B0C4DE size=4 face="黑体"><span class="math inline">\(P(B|A)=\frac{P(AB)}{P(A)}\)</span></font>，注意这要求<span class="math inline">\(P(A)\neq 0\)</span>.<font color=#F08080 size=4 face="黑体">概率为0的事件不一定只有不可能事件哦！</font></p>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/10/13/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/10/13/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="测试一下吧">测试一下吧！</h1><p>测试好了就贴上芙宝的教堂图！！！ <img src="https://www.helloimg.com/i/2024/10/13/670b4eb055555.jpg" alt="极昼机体" /></p>]]></content>
    
    
    <categories>
      
      <category>划水</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/13/hello-world/"/>
    <url>/2024/10/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>划水</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
